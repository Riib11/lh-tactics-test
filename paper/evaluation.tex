\section{Evaluation}

% % ? BEGIN OUTLINE

% The benefits we aim to provide with these proof macros are:
% - conciseness: the macros cater towards a specific subset of LH that is used
%   for extrinsic-style proofs, so the interface to this subset can be more
%   specific and restricted than generic programs
% - reduced redundancy: often, multiple logical branchings can be handled by the
%   same proof macro (due to the modularity the macros achieve in a similar
%   style to tactics), and proof macro branchings (such as destruct, induct,
%   condition) allow the handling proof macro to be written just once and then
%   used in all of the branches
% - modularity: in the same style as tactics, the auto proof macro is contextual
%   and so the same use of auto can be used to solve many different proof goals
%   by leveraging contextual information such as the lemmas, variables, and
%   sound recursions.

% To verify the applicability of these benefits, we selected an
% independently-curated collection of properties to be proved in an extrinsic
% style using Liquid Haskell: https://github.com/mustafahafidi/qc-to-lh. The
% original use of these properties was to demonstrate the usefulness of another
% approach to generating Liquid Haskell proofs that has some similarities to our
% approach.

% TODO: describe similarities and differences The properties are relatively
% basic properties about the natural numbers, lists of natural numbers or pairs
% of natural numbers, and trees of natural numbers.

% % ? END OUTLINE

The proof macro system introduced in this paper aims to provide the following
benefits to Liquid Haskell proof developers.

\paragraph{Conciseness.} Extrinsic proofs are mostly written in a
particular subset of Haskell, the \LangB. So, the proof macros can give a more
concise interface to writing terms specifically in \LangB. As a result, we
expect the proofs of a wide variety of theorems to each be much shorter when
written as a proof macro compared to when written in general Haskell code.
%
\paragraph{Reduced redundancy.} As is demonstrated frequently with Coq's
``\LC{;}'' tactic combinator, often all branches of a control flow branching
can be handled by the same proof strategy. Rather than require the user to
provide their implementation of that proof strategy in each branch or to
define various lemmas to encapsulate the relevant contexts in each branch, the
macros automatically apply the once-written proof strategy (encoded by the
sequence of proof macros that follow the control flow proof macro) in each
branch. See figure \ref{fig:assoc-min-proof} for an example of how
significantly this can contract proof terms.
%
\paragraph{Modularity.} Even though many proofs can be encapsulated by the
same proof strategy (e.g. simple induction) vanilla Liquid Haskell requires
that strategy to be written out in full verbosity in each instance (e.g.
pattern matching on a list of a natural number, and then supplying the tail or
predecessor to the recursive call in the second cases respectively). The proof
macro system allows the user to efficiently and modularly encode proof
strategies in such a way that the same sequence of proof macros can be used to
prove a wide variety of similar theorems that use the same proof strategy.

\paragraph{Practicality} % TODO

\smallskip

\todo{wording; how much detail to include here}
To evaluate these claims, we proved an independently-selected set of 84 Liquid
Haskell theorems that were used in previous work as a benchmark for a Liquid
Haskell proof automation tool \todo{include citation,
https://github.com/mustafahafidi/qc-to-lh}. The benchmark consists of a
collection of predicates (i.e. Haskell functions that return \LC{Bool}) over
natural numbers, lists, and binary trees that mostly can be proven to hold over
all inputs using simple proof strategies and a few theorem-specific, admitted
lemmas.

We measured \todo{definitions of our measurements}

\begin{figure}
  % TODO: gather this data
  \todo{include table here, perhaps with some sort of categorization of the proofs? not sure exactly what data to show in the table}
  \label{fig:evaluation}
\end{figure}

\todo{ideas for data to include
\begin{itemize}
  \item percent of inductive proofs that were proven with just ``induct x1; ...
  induct xN''
  \item percent of proofs that resulted in set of auto-generationed exps that
  were too large to prune automatically
  \item number of lines in proof macro vs number of lines in generated proof
  term
\end{itemize}
}

Each of the theorems were able to be proven using the proof macro system more
consisely than the generated proof term.

\todo{pick a few interesting examples?}

% -- prop15_lemma
%
% {-@ reflect prop15_lemma @-} prop15_lemma :: N -> N -> ListN -> Bool
% prop15_lemma n x l = lengthListN (insertListN n l) == lengthListN (Cons x l)
%
% return []
%
% {-@ automatic-instances prop15_lemma_proof @-}
% {-@
% prop15_lemma_proof :: n:N -> x:N -> l:ListN -> {prop15_lemma n x l}
% @-}
% -- %tactic:begin:prop15_lemma_proof prop15_lemma_proof :: N -> N -> ListN ->
% Proof prop15_lemma_proof = \n -> \x -> \l -> case l of Data.Nil -> trivial
% Data.Cons n_0 listN_1 -> prop15_lemma_proof n x listN_1 --
% %tactic:end:prop15_lemma_proof
%
% -- [tactic| -- prop15_lemma_proof :: N -> N -> ListN -> Proof --
% prop15_lemma_proof n x l = --   induct l
% -- |]
%
% -- prop15
%
% {-@ reflect prop15 @-} prop15 :: N -> ListN -> Bool prop15 n l = lengthListN
% (insertListN n l) == S (lengthListN l)
%
% return []
%
% {-@ automatic-instances prop15_proof @-}
% {-@
% prop15_proof :: n:N -> l:ListN -> {prop15 n l}
% @-}
% -- %tactic:begin:prop15_proof prop15_proof :: N -> ListN -> Proof prop15_proof
% = \n -> \l -> case l of Data.Nil -> trivial Data.Cons n_0 listN_1 ->
% prop15_proof n listN_1 -- %tactic:end:prop15_proof
%
% -- [tactic| -- prop15_proof :: N -> ListN -> Proof -- prop15_proof n l = --
% induct l; --   auto [prop15_lemma_proof]
% -- |]
%
% -- prop20_lemma
%
% {-@ reflect prop20_lemma @-} prop20_lemma :: N -> ListN -> Bool prop20_lemma h
% t = lengthListN (insertListN h (sortListN t)) == S (lengthListN (sortListN t))
%
% return []
%
% {-@
% prop20_lemma_proof :: h:N -> l:ListN -> {prop20_lemma h l}
% @-}
% prop20_lemma_proof :: N -> ListN -> Proof prop20_lemma_proof h l = undefined
%
% -- prop20
%
% {-@ reflect prop20 @-} prop20 :: ListN -> Bool prop20 l = lengthListN
% (sortListN l) == lengthListN l
%
% return []
%
% {-@ automatic-instances prop20_proof @-}
% {-@
% prop20_proof :: l:ListN -> {prop20 l}
% @-}
% -- %tactic:begin:prop20_proof prop20_proof :: ListN -> Proof prop20_proof = \l
% -> case l of Data.Nil -> trivial Data.Cons n_0 listN_1 -> prop20_proof listN_1
% &&& prop20_lemma_proof n_0 listN_1 -- %tactic:end:prop20_proof
%
% -- [tactic| -- prop20_proof :: ListN -> Proof -- prop20_proof l = --   induct
% l; --   auto [prop20_lemma_proof]
% -- |]
%
% % prop 24
%
% {-@ reflect prop @-} prop a b = ((maxN a b) == a) == (leqN b a)
%
% {-@ automatic-instances proof @-}
% {-@
% proof :: a:N -> b:N -> {prop a b}
% @-}
% -- [tactic| -- proof :: N -> N -> Proof -- proof a b = induct a; induct b
% -- |]
% -- %tactic:begin:proof proof :: N -> N -> Proof proof = \a -> \b -> case a of
% Data.Z -> case b of Data.Z -> trivial Data.S n_0 -> trivial Data.S n_0 -> case
% b of Data.Z -> trivial Data.S n_1 -> proof n_0 n_1 -- %tactic:end:proof
%
% % prop27
%
% module TIP.Prop27 where
%
% import Data import Proof import Tactic.Core.Quote
%
% {-@ reflect prop @-} prop x xs ys = if elemListN x ys then elemListN x
% (concatListN xs ys) else True
%
% {-@ automatic-instances proof @-}
% {-@
% proof :: x:N -> xs:ListN -> ys:ListN -> {prop x xs ys}
% @-}
% -- elemListN x1 (concatListN (Cons x2 xs) ys) -- elemListN x1 (Cons x2
% (concatListN xs ys)) -- if x1 == x2 then --   QED -- else --   elemListN x1
% (concatListN xs ys) -- [tactic| -- proof :: N -> ListN -> ListN -> Proof --
% proof x xs ys = --   induct xs; --   condition {elemListN x ys}
% -- |]
% -- %tactic:begin:proof proof :: N -> ListN -> ListN -> Proof proof = \x -> \xs
% -> \ys -> case xs of Data.Nil -> if elemListN x ys then trivial else trivial
% Data.Cons n_0 listN_1 -> if elemListN x ys then proof x listN_1 ys else
% trivial -- %tactic:end:proof
%
% % prop31
%
% {-@ reflect prop @-} prop a b c = minN (minN a b) c == minN a (minN b c)
%
% {-@ automatic-instances proof @-}
% {-@
% proof :: a:N -> b:N -> c:N -> {prop a b c}
% @-}
% -- [tactic| -- proof :: N -> N -> N -> Proof -- proof a b c = induct a; induct
% b; induct c
% -- |]
% -- %tactic:begin:proof proof :: N -> N -> N -> Proof proof = \a -> \b -> \c ->
% case a of Data.Z -> case b of Data.Z -> case c of Data.Z -> trivial Data.S n_0
% -> trivial Data.S n_0 -> case c of Data.Z -> trivial Data.S n_1 -> trivial
% Data.S n_0 -> case b of Data.Z -> case c of Data.Z -> trivial Data.S n_1 ->
% trivial Data.S n_1 -> case c of Data.Z -> trivial Data.S n_2 -> proof n_0 n_1
% n_2 -- %tactic:end:proof
%
% -- prop47_lemma
%
% {-@ reflect prop47_lemma @-} prop47_lemma :: N -> N -> Bool prop47_lemma m n =
% maxN m n == maxN n m
%
% return []
%
% {-@ automatic-instances prop47_lemma_proof @-}
% {-@
% prop47_lemma_proof :: m:N -> n:N -> {prop47_lemma m n}
% @-}
% prop47_lemma_proof :: N -> N -> Proof prop47_lemma_proof m n = undefined
%
% -- prop47
%
% {-@ reflect prop47 @-} prop47 :: TreeN -> Bool prop47 t = heightTreeN t ==
% heightTreeN (mirrorTreeN t)
%
% return []
%
% {-@ automatic-instances prop47_proof @-}
% {-@
% prop47_proof :: t:TreeN -> {prop47 t}
% @-}
% -- %tactic:begin:prop47_proof prop47_proof :: TreeN -> Proof prop47_proof = \t
% -> case t of Data.Leaf -> trivial Data.Node n_0 treeN_1 treeN_2 ->
% prop47_proof treeN_2 &&& (prop47_proof treeN_1 &&& prop47_lemma_proof
% (heightTreeN treeN_2) (heightTreeN treeN_1)) -- * finds even more efficient
% proof than I thought of! -- %tactic:end:prop47_proof
%
% -- [tactic| -- prop47_proof :: TreeN -> Proof -- prop47_proof t = induct t;
% auto [prop47_lemma_proof, heightTreeN, mirrorTreeN] 3
% -- |]
%
% % prop52
%
% {-@ automatic-instances lemma @-}
% {-@
% lemma :: n:N -> xs:ListN -> ys:ListN -> {countListN n (concatListN xs ys) ==
% countListN n (concatListN ys xs)}
% @-}
% lemma :: N -> ListN -> ListN -> Proof lemma n xs ys = undefined
%
% return []
%
% -- * takes 3m47s to prune {-@ automatic-instances proof @-}
% {-@
% proof :: n:N -> xs:ListN -> {countListN n xs == countListN n (reverseListN
% xs)}
% @-}
% -- %tactic:begin:proof proof :: N -> ListN -> Proof proof = \n -> \xs -> case
% xs of Data.Nil -> trivial Data.Cons n_0 listN_1 -> proof n listN_1 &&& lemma n
% (singletonListN n_0) (reverseListN listN_1) -- %tactic:end:proof -- [tactic|
% -- proof :: N -> ListN -> Proof -- proof n xs = --   induct xs; --   auto
% [lemma, reverseListN, singletonListN] 3
% -- |]
%
% % prop68
%
% {-@
% lemma1 :: a:N -> b:N -> c:N -> {(leqN a b && leqN b c) => leqN a c}
% @-}
% lemma1 :: N -> N -> N -> Proof lemma1 a b c = undefined
%
% {-@ lemma2 :: a:N -> {leqN a (S a)} @-} lemma2 :: N -> Proof lemma2 =
% undefined
%
% return []
%
% {-@ reflect prop @-} prop x ys = lengthListN (deleteListN x ys) `leqN`
% lengthListN ys
%
% {-@ automatic-instances proof @-}
% {-@
% proof :: x:N -> ys:ListN -> {prop x ys}
% @-}
% -- [tactic| -- proof :: N -> ListN -> Proof -- proof x ys = --   induct ys as
% [/y ys']; --   condition {x == y} requires [y]; --   use {lemma1 (lengthListN
% (deleteListN x ys')) (lengthListN ys') (lengthListN ys)} requires [y, ys']; --
% auto [lemma2, lengthListN]
% -- |]
% -- %tactic:begin:proof proof :: N -> ListN -> Proof proof = \x -> \ys -> case
% ys of Data.Nil -> trivial Data.Cons y ys' -> if x == y then lemma1
% (lengthListN (deleteListN x ys')) (lengthListN ys') (lengthListN ys) &&&
% (proof y ys' &&& lemma2 (lengthListN ys')) else lemma1 (lengthListN
% (deleteListN x ys')) (lengthListN ys') (lengthListN ys) &&& proof x ys' --
% %tactic:end:proof

% TODO: this has been moved to further-work.tex
% \subsection{Limitations}

% Although the evaulation provides significant evidence that the proof macro
% system can in many cases meet our goals, it also comes with several limitations.
% \todo{should I just talk about these all in the further work section?}

% \paragraph{No polymorphism for \LC{auto}.} The \LC{auto} macro cannot handle
%   polymorphism, because it only uses syntactic equality when checking if an
%   value's type is compatible with the type expected for an argument in a neutral
%   form being generated.

% \paragraph{No abstract macros.} There is no way to define a \textit{abstract}
%   macro that expands into a sequence of macros. This results in needless
%   redundancy where many proofs contain the same sequence of macros, differing
%   only in the particular argument given.
  
% \paragraph{Slow pruning algorithm.} The pruning algorithm used is guaranteed to
%   find the subset of the \LC{auto}-generated \textit{exp}s that make the proof
%   pass, if such a subset exists, but it is a slow process. As show in figure
%   \ref{fig:evaluation}, sometimes the number of \textit{exp}s geneated is too
%   large to be pruned in a reasonable amount of time. \todo{how to qualify this
%   formally? just pick a time limit?}
  
% \paragraph{No \LC{auto} hints with refined argument types.} If an \LC{auto}
%   macro is given a hint \LC{h :: (a:A | f a) -> B}, where \LC{f :: A -> Bool} is
%   a predicate over \LC{A}, the proof macro system may generate a neutral form
%   \LC{f x} where Liquid Haskell cannot deduce that \LC{f x} holds. In this
%   situation, Liquid Haskell will reject the proof before pruning begins, so the
%   problematic neutral form cannot be pruned. The proof macro system has no way
%   to filter out these sorts of neutral forms because Template Haskell doesn't
%   have access to refinement information.