\section{Implementation}

The proof macro system involves two stages:
- preprocessing:
  - preprocess EDSL into augmented subset of Haskell
  - embed augmented subset of Haskell into Haskell
- pruning:
  - pruning algorithm over augmented subset of Haskell 
    - augmentation keeps track of pruning-relevant metadata e.g. which terms have been prune/kept from an auto site
    - in each step of the pruning algorithm, checks if current prune is valid by embedding the current pruned expression into Haskell then running Liquid Haskell

\subsection{Preprocessing}

The proof macro is written by the user in an ESDL that appears inside a Haskell quasiquotation.
The EDSL has the following syntax:
\begin{align*}
  \textit{decl}~ ::= &
    \textit{name} ~ : ~ \textit{type} \\ &
    \textit{name} ~ \overline{\textit{name}} ~ = ~ \overline{\textit{instr} ; }
  \\
  \textit{instr} ~ ::= &
    \textbf{intro} ~ \textit{name} \\ | &
    \textbf{destruct} ~ \textit{name} ~ (\textbf{as} ~ \textit{destruct-pat}) ([\overline{\textit{flag},}]) \\ | &
    \textbf{induct} ~ \textit{name} ~ (\textbf{as} ~ \textit{pat}) ([\overline{\textit{induct-flag},}]) \\ | &
    \textbf{auto} ~ (\overline{\textit{name},}) (\textit{nat}) \\ | &
    \textbf{condition} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{assert} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{dismiss} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{use} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{trivial}
\end{align*}

The above proof macro ESDL is preprocessed into an augmented subset of Haskell. 
The particular subset is exactly the image of the EDSL preprocessor.
The conceptual distinction between the ESDL and the augmented substet is that preprocessing the EDSL requires a context and producing many expressions per single EDSL instruction. 
The augmented subset 

\subsection{Pruning}