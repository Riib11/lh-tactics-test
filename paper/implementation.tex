\section{Implementation}


The proof macro system introduced by this paper addresses these concerns and more by providing a macro interface to the user that allows them to concisely express terms of the subset of Haskell code that is useful for writing these SMT guides through Haskell control flow.

The proof macro system defines a DSL that can be written in "tactic" quasiquotes, and then this DSL term is expanded to the verbose Haskell term after type checking and pruning (to be explained soon).



The overarching idea behind the proof macro system is that an extrinsic proof has the following structure, involving two kinds of components:
I. match control flow (e.g. conditions, cases, anything that adds information to the refinement context) of some functions that appear in the specification
II. at each leaf of the resulting control-flow structure, use some lemmas and/or recursions to provide enough information to the refinement context that the SMT can automatically check that leaf's goal.


The proof macro system provides macros for each kind of component:
Macros I:
- induct x: does case analysis on x, and if x was an input variable then notes that in each match, the pattern's variables are valid to use in recursive calls at the position of the input variable (this is taken to account in the "auto" c)
- destruct x: does case analysis on x
- assert b: conditions on b and treats the False case as trivial 
- dismiss b: conditions on b and treats the True case as trivial
- condition b: conditions on b and handles both cases
Macros II:
- auto: generates all well-typed applications of terms in context (with output type Proof), using terms in context, up to a depth
- use e: includes the refinement of the expression e into the refinement context
- trivia: includes the trivial proof into the refinement context

The proof of "assoc\_min" can be expressed shortly as follows:


The "induct a" macro does case analsis on "a", resulting in two branches. Since both branches are to be handled, the following two macros are executed in both branches (matching the behavior of the ";" tactic combinator in Coq).
Additionally, in the "S a'" case, the "induct a" tactic notices that "a'" was introduced by inducting on an input variable term in positon 0, so "a'" is marked as a valid argument to a recursive call to "assoc\_min" in position 0.
The same happens for "induct b" and "induct c", yielding the same branches of the verbose Haskell term.
Finally, every proof macro implicitly ends with "auto" unless it ends with "trivial" or "use e".
So, in each of the 9 branches, "auto" is executed to generate all well-typed terms of type "Proof" using things in local context.
In all but the "S a', S b', S c'" case, there are no such well-typed applications, since the only way to produce a term of type "Proof" is to use "assoc\_min", but only in that final is there a term in context that is available to use as the argument to a recursive call to "assoc\_min", for each of its argment positions (which are 0, 1, 2 since it has 3 arguments and each is inducted on).


There are two EDSLs:
- EDSL1 (proof macro EDSL): the EDSL that the user uses to write proof macros
- EDSL2: the subset of Haskell that proof macros can expand into i.e. the image of EDSL1 under preprocessing, augmented with metadata used in pruning

The proof macro system involves two stages:
- preprocessing:
  - preprocess ESL1 into EDSL2
  - embed EDSL2 into Haskell code to be spliced
- pruning:
  - pruning algorithm over EDSL2 
    - EDSL2 has pruning-relevant metadata e.g. which terms have been prune/kept from an auto site
    - in each step of the pruning algorithm, checks if current prune is valid by embedding the current pruned expression into Haskell then running Liquid Haskell

\subsection{Preprocessing}

EDSL1 is used by the user to write proof macros inside of quasiquotes of the form \texttt{[tactic|...|]}

%Grammar of EDSL1:
\begin{align*}
  \textit{decl}~ ::= &
    \textit{name} ~ : ~ \textit{type} \\ &
    \textit{name} ~ \overline{\textit{name}} ~ = ~ \overline{\textit{instr} ; }
  \\
  \textit{instr} ~ ::= &
    \textbf{intro} ~ \textit{name} \\ | &
    \textbf{destruct} ~ \textit{name} ~ (\textbf{as} ~ \textit{destruct-pat}) ([\overline{\textit{flag},}]) \\ | &
    \textbf{induct} ~ \textit{name} ~ (\textbf{as} ~ \textit{pat}) ([\overline{\textit{induct-flag},}]) \\ | &
    \textbf{auto} ~ (\overline{\textit{name},}) (\textit{nat}) \\ | &
    \textbf{condition} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{assert} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{dismiss} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{use} ~ \textit{exp} ~ (\textbf{requires} ~ [\overline{\textit{name},}]) \\ | &
    \textbf{trivial}
\end{align*}

The language EDSL1, defined above, is preprocessed into EDSL2 which is a subset of Haskell augmented with metadata. 
The conceptual distinction between EDSL1 and EDSL2 is that preprocessing EDSL1 requires a context and producing many expressions per single EDSL1 instruction, whereas EDSL2 is strictly an embedding into Haskell and so each EDSL2 expression corresponds to exactly one Haskell expression.

Grammar of EDSL2:
\begin{align*}
  \textit{decl}~ ::= &
    \textit{name} ~ : ~ \textit{type} \\ &
    \textit{name} ~ \overline{\textit{name}} ~ = ~ \textit{expr}
  \\
  \textit{expr}~ ::= &
    \mathbf{\lambda} ~ \textit{name} ~ \textbf{->} ~ \textit{instr} \\ &
    \textbf{case} ~ \textit{exp} ~ \textbf{of} ~ \overline{\textit{pat} ~ \textbf{->} ~ \textit{exp} ;} \\ & 
    \textbf{if} ~ \textit{exp} ~ \textbf{then} ~ \textit{exp} ~ \textbf{else} ~ \textit{exp} \\ & 
    \textbf{auto} ~ [\overline{\textit{exp} ;}] \textit{pruning-metadata} \\ & 
    \textbf{trivial}
\end{align*}

An EDSL1 declaration is preprocessed into an EDSL2 declaration like so:

\begin{verbatim}
preprocDecl : EDSL1-decl -> EDSL2-decl
preprocDecl (name, args, type, instrs) =
  set function name to name
  set output type to type
  for each arg
    get output type as a -> b 
    store type of arg as a
    set output type to b
  preproc instrs

// stateful
preproc : [EDSL1-instr] -> EDSL2-expr
preproc [] = []
preproc (instr : instrs) = case instr of 
  intro x -> do
    [|a <- b|] <- get output type
    type of x := a
    output type := b
    [|\x -> $(preproc instrs)|]
  destruct exp requires xs -> do
    if all of xs are in scope then 
      varss <- get patterns for deconstructing exp
      constrs <- constructors of the datatype of exp
      matches <- 
        for each (vars, constr) in (varss * constrs)
          args <- argument types of constr
          for each (var, arg) in in (pats * args)
            type of var := arg
          [|ps -> $(preproc instrs)|]
      [|case exp of matches|]
    else
      preproc instrs
  induct exp requires xs -> do
    if all of xs are in scope then 
      varss <- get patterns for deconstructing exp
      constrs <- constructors of the datatype of exp
      matches <-
        for each (vars, constr) in (varss * constrs)
          args <- argument types of constr
          for each (var, arg) in in (pats * args)
            if exp is an argument to the top-level proposition then
              add var to context of recursive-safe expression to fill the
              respective argument of a recursive call
            type of var := arg
          [|ps -> $(preproc instrs)|]
      [|case exp of matches|]
    else
      preproc instrs
  auto hints depth ->
    generate all neutral forms in context, up to depth
    when a recursion is generated, at least one of its arguments must be something from the context of recursive safe expressions for that argument (which is populated via induct)
  assert exp requires xs ->
    if all of xs are in scope then
      [|if exp then $(preproc instrs) else True|]
    else
      preproc instrs
  dismiss exp requires xs ->
    if all of xs are in scope then
      [|if exp then True else $(preproc instrs)|]
    else
      preproc instrs
  use exp requires xs -> 
    [|use exp &&& $(preproc instrs)]
  condition exp requires xs ->
    [|if exp then $(preproc instrs) else $(preproc instrs)]
  trivial ->
    [|trivial|]


\end{verbatim}

\subsection{Pruning}

\subsubsection{Linear Pruning}

For each auto site (i.e. each apreprocearance of \textbf{auto} in the preprocessed EDSL2), each \textit{exp} it uses is pruned one at a time, checking to see if Liquid Haskell still passes after the pruning. If a prune succeeds the pruned \textit{exp} is discarded, otherwise the pruned \textit{exp} is returned to the original \textbf{auto} site.
