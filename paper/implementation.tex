\section{Liquid Proof Macros}

% Organization idea:
% \begin{enumerate}
%   \item Overview the entire procedure:
%   \begin{enumerate}
%     \item The user writes a proof macro term in ``tactic'' quasiquotes as their proof, in EDSL1 i.e. the proof macro language
%     \item The proof macro term is processed into a ``proto proof term'' in EDSL2 i.e. the metadata-augmented subset of Haskell relevant for extrinsic proofs
%     \item The ``proto proof term'' is embedded into Haskell, then spliced the place of the original proof macro. The file is checked.
%     \item If the check passes, then the proto proof term is pruned by repeatedly pruning the proto proof term, embedding and splicing it into the place of the original proof macro, and checking if the pruned result still passes.
%     \item The resulting proof term is a valid proof as determined by Liquid Haskell.
%   \end{enumerate}
%   \item Detail the features of EDSL1 and the intended behaviors
%   \item Briefly describe the details of EDSL2
%   \begin{enumerate}
%     \item Describe how each feature in EDSL1 is implemented by a processing transformation into EDSL2
%     \item Preprocessing EDSL1 into EDSL2 is a contextual transformation, since it needs to keep track of an environment which includes various information (see Language.Core.Syntax.Environment'')
%     \item How the ``auto'' term in EDSL2 includes metadata for which terms have have been pruned and which have been determined necessary.
%   \end{enumerate}
%   \item Detail pruning procedure
%   \begin{enumerate}
%     \item Clearly, this can be done more efficiently.
%     \item Point out further possible work like checking for well-typed applications where the function has refined argument types.
%   \end{enumerate}
% \end{enumerate}

% 
% * real start
% 
  
\todo{is {process} the right term? or {preprocess}, or {expand}, or {elaborate}? something that describes converting a macro to its fully-concretized form}
\leo{I'd guess ``expand'' since we're naming them macros.}

\todo{figure out standard vocabularly for referring to different parts of macro system and LH:
--- a {declaration}? defines the name, type, and arguments of a top-level definition
--- a {proof macro declaration}? is the macro that processes to a definition
--- a {proof macro}? is a macro that goes in the sequence of macros in a {proof macro definition}
}

Going from a proof macro like the one we saw earlier in
Figure~\ref{fig:assoc-min-macro} to a low-level Liquid Haskell proof
such as the one in Figure~\ref{fig:ref-assoc-min-proof} is a
multi-stage process, which we will describe in detail in this section.

\begin{itemize}
\item First, users need to write a proof in the \LangA, an extensible
  collection of high-level constructs (such as \LC{induct}) that
  facilitate SMT reasoning (Section~\ref{sec:proof-macro-lang}).
\item Terms in this language are then expanded into terms in a \LangB,
  a subset of Haskell that can be used as Liquid Haskell proofs, but
  annotated with metadata that are necessary for simplifications
  (Section~\ref{sec:proto-proof-lang}). Each such \LangBTerm is cached,
  embedded into Haskell, and then spliced in place of the original
  proof macro.
\item Finally, cached terms are repeatedly pruned to remove
  potentially unnecessary proof terms, using Liquid Haskell as the
  validity oracle (Section~\ref{sec:pruning}).
  
\end{itemize}

% 
%The proof macro system processes an input proof macro into an output Liquid Haskell proof into stages:
%\begin{enumerate}
%  \item 
%  The user writes the input proof macro in Template Haskell quasiquotes. 
%  Then the user runs \TheTool \todo{how to talk about this executable} on the file containing the target proof macro to process. 
%  The quasiquoted proof macro is parsed into \LangA.
%  \item
%  The \LangATerm is processed into a corresponding \LangBTerm, and all metadata values are given initial defaults.
%  \item
%  The \LangBTerm is cached, embedded into Haskell, and then spliced in place of the original proof macro. 
%  \item 
%  The cached \LangBTerm is repeatedly pruned, using metadata to track pruning progress, where each pruning step involves removing some proof terms contained inside of the entire \LangBTerm, embedding and splicing it in place of the original proof macro, and then running Liquid Haskell to check that the prune step was valid.
%\end{enumerate}
%  
\subsection{The \LangA}
\label{sec:proof-macro-lang}


The \LangA defines a collection of proof macros that aim to concisely
describe the high-level structure of a Liquid Haskell proof. This
collection is designed to be extendible, so that new proof macros can
be added easily by adding a new constructor to the \LangA and then
handling the new case for processing.  The syntax for \LangA appears
in Figure~\ref{fig:proof-macro-lang}.

\begin{figure}
\begin{align*}
  \textit{decl-macro} ::= &
    ~ f ~ : ~ \textit{typ} \\ &
    ~ f ~ \overline{y_i} ~ = ~ \overline{\textit{exp-macro} ;}
  \\[1em]
  \textit{exp-macro} ::= &
    ~ \MC{induct} ~ x \\ \mid &
    ~ \MC{destruct} ~ \text{exp} \\ \mid &
    ~ \MC{assert} ~ \textit{exp} \\ \mid &
    ~ \MC{dismiss} ~ \textit{exp} \\ \mid &
    ~ \MC{condition} ~ \textit{exp} \\ \mid &
    ~ \MC{auto} ~ [\overline{\textit{x} ,}] ~ n \\ \mid &
    ~ \MC{use} ~ \textit{exp} \\ \mid &
    ~ \MC{trivial}
  \\[1em]
  \textit{exp} ::= & ~ \textit{Haskell expression} 
  \\
  \textit{typ} ::= & ~ \textit{Haskell type (monomorphic)} 
  \\
  f, x, y_i ::= & ~ \textit{Haskell name} 
  \\
  n \in & ~ \mathbb{N}
\end{align*}
\caption{The proof macro language}
\label{fig:proof-macro-lang}
\end{figure}

\leo{TODO: Names need to be parallel. Control-flow/evidence;
  control-flow altering/evidence providing? Maybe finalizers?}

We can broadly identify two types of proof macros: {\em evidence} and
{\em control-flow} macros.

\paragraph{Evidence Macros}

\textit{Evidence} macros are processed into terms that provide
evidence to the Liquid Haskell typechecker, such as introducing a
lemma to the refinement context. The last three constructs in
Figure~\ref{fig:proof-macro-lang} exhibit such functionality:

\begin{itemize}

\item $\MC{trivial}$:

  This macro expands into Liquid Haskell's \LC{trivial :: Proof} in
  the resulting Haskell term. Since $\MC{trivial} = \MC{()}$ and
  $\MC{Proof} = \MC{()}$, using this macro effectively means that the
  SMT solver can discharge any remaining obligations.

\item $\MC{use} ~ \textit{exp}$:

  This macro makes the refinement type of the expression available
  to the SMT solver, similar to how \LC{assoc_min a' b' c'} was needed
  to conclude the proof in Figure~\ref{fig:assoc-min-proof}.
  
\item $\MC{auto} ~ [\overline{\textit{x} ,}] ~ n$:

  This is the most complicated proof macro, and the core of our
  frameworks automation. It takes two optional parameters, a sequence
  $\overline{\textit{x}}$ of {\em hints}, and a natural number $n$,
  and it generates all well-typed neutral forms of type \LC{Proof} up
  to height $n$ that use variables from the current context or the
  hints. To ensure recursive calls are terminating, we keep track of a
  separate recursion context that is specially constructed in the rest
  of the proof (see the control-flow macros below).
\end{itemize}

If a sequence of macros given by the user does {\em not} end in an
evidence macro, then a default \LC{auto} macro with no hints and height
\LC{3} will be implicitly included at the end of the sequence. That is,
the proof macro of Figure~\ref{fig:assoc-min-macro} is equivalent to
the following one:
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
        {min (min a b) c == min a (min b c)} @-}
  [tactic|
    assoc_min :: N -> N -> N -> Proof
    assoc_min a b c = induct a; induct b; induct c; auto [] 3
  |]
\end{code}

\paragraph*{Control-Flow macros}

Control flow macros correspond to proof terms that alter the control
flow of the program, such as pattern matching. Whenever such macros
introduce multiple branches, the rest of the sequence of proof macros
is expanded into each such branch. The first five constructs from
Figure~\ref{fig:proof-macro-lang} exhibit such functionality:

\begin{itemize}
\item $\MC{induct} ~ x$:

  This macro creates a pattern match on $x$, which is assumed to be a
  function argument defined in the macro declaration, using the typing
  information available to Template Haskell.  In each case of the
  pattern match, any pattern variables are only included in the recursion
  context at the corresponding argument position of $x$, and the
  original $x$ is removed. This ensures that \LC{auto} will not construct
  non-terminating recursive calls.

\item $\MC{destruct} ~ \textit{exp}$:

  This macro corresponds to simple case analysis. Similarly to
  \LC{induct}, it creates a pattern match on $\textit{exp}$, but it
  does not modify the recursion context.  --- pattern matches on
  $\textit{exp}$. 

\item $\MC{condition} ~ \textit{exp}$:

  This macro conditions on $\text{exp}$ creating an \LC{if} statement
  in the proof term. A macro-processing branch is created for each of
  the \MC{then} and \MC{else} branches respectively.

\item $\MC{assert} ~ \textit{exp}$:

  Simplified version of \LC{condition}, that only creates a
  macro-processing branch for the \MC{then} branch, while the
  \MC{else} branch is only filled with \MC{trivial}.
  
\item $\MC{dismiss} ~ \textit{exp}$:

  Dual of \LC{assert}.

\end{itemize}

For concreteness, as a running example for the rest of the paper, consider
the following interaction between the list append and membership functions,
\footnote{For the sake of readability, we used the usual list
  notations such as (++) for list append, rather than their refined
  list counterparts.}%
%
which states that if a number \LC{x} is an element of a list \LC{xs},
then \LC{x} is also in the list \LC{xs ++ ys} for an arbitrary list \LC{ys}:
\begin{code}
  concatElemP :: N -> [N] -> [N] -> Bool
  concatElemP x xs ys
    | elem x xs = elem x (xs ++ ys)
    | otherwise = True

  {-@ concatElem :: x:N -> xs:[N] -> ys:[N] ->
      {concatElemP x xy ys} @-}
  [tactic|
  concatElem :: N -> [N] -> [N] -> Proof
  concatElem x xs ys =
    assert {elem x xs};
    induct xs;
    auto -- This is unnecessary!
  |]
\end{code}

At a high level, what this proof macro does is condition on the
expression \LC{elem x xs} (from the \LC{assert} macro), pattern match
on \LC{xs} (from the \LC{induct} macro), and search for ways to
complete the proof, potentially using the tail of \LC{xs} for a
recursive call (from \LC{auto}). This is achieved by expanding these
macros back into a subset of Haskell, which we call the {\em \LangB}.

\subsection{The \LangB}

The \LangB is at its core a subset of Haskell expressions with some
additional metadata.  Figure~\ref{fig:langb-syntax} depicts its
syntax, which contains lambdas, pattern matching with case, if
statements, Liquid Haskell's conjunction \LC{&&&} and \LC{trivial}, as
well as a special construct \LC{Auto} that keeps track of 3 lists of
arbitrary Haskell expressions. 

\begin{figure}
\begin{align*}
  \textit{decl-proto} ::= &
  ~ f ~ : ~ \textit{typ} \\ &
  ~ f ~ = ~ \overline{\textit{exp-proto} ;}
  \\
  \textit{exp-proto}~ ::= &
    ~ \MC{\lambda} ~ \textit{name} ~ \MC{\rightarrow} ~ \textit{exp-proto} \\ \mid &
    ~ \MC{case} ~ \textit{exp} ~ \MC{of} ~ \overline{\textit{pat} ~ \MC{\rightarrow} ~ \textit{exp-proto} ;} \\ \mid &
    ~ \MC{if} ~ \textit{exp} ~ \MC{then} ~ \textit{exp-proto} ~ \MC{else} ~ \textit{exp-proto} \\ \mid &
  % ~ \MC{Auto} ~ \{ \textit{init}~=~[\overline{\textit{exp}},], ~ \textit{kept}~=~[\overline{\textit{exp}},], ~ \textit{pruned}~=~[\overline{\textit{exp}},] \} ~ \&\&\& ~ \textit{exp-proto} \\ \mid &
    ~ \&\&\& ~ \textit{exp-proto} \\ \mid &
    ~ \textit{exp} ~ \&\&\& ~ \textit{exp-proto} \\ \mid &
    ~ \text{trivial} \\ \mid &
    ~ \MC{Auto} \\ &
    ~ \hspace{0.5em} \{ \textit{init}~=~[\overline{\textit{exp}},], \\ &
    ~ \hspace{0.5em} \textit{kept}~=~[\overline{\textit{exp}},], \\ &
    ~ \hspace{0.5em} \textit{pruned}~=~[\overline{\textit{exp}},] \} \\ &
  \\[1em]
  \textit{exp} ::= & ~ \textit{Haskell expression} 
  \\
  \textit{pat} ::= & ~ \textit{Haskell pattern} 
  \\
  \textit{typ} ::= & ~ \textit{Haskell type (monomorphic)} 
  \\
  f, x ::= & ~ \textit{Haskell name} 
  \\
  n \in & ~ \mathbb{N}
\end{align*}
\caption{Syntax of the \LangB}
\label{fig:langb-syntax}
\end{figure}

With the exception of \LC{Auto}, terms in the \LangB can be directly
embedded into Haskell. In turn, \LC{Auto} can be embedded by
translating the \LC{kept} and \LC{init} lists of expressions to
sequences of Liquid Haskell conjunctions---the reason will become
apparent when we discuss pruning below.
\begin{code}
  Auto { init = [a1, ..., aM]
       , kept = [b1, ..., bN]
       , pruned = _ } ==>
  a1 &&& ... &&& aM &&& b1 &&& ... &&& bN
\end{code}

\leo{Semantics of proof macros as proto-buf?}
\todo{should I convert this to an algorithmic format? or should I just not include this algorithm's full detail at all}
A \LangA term is processed into an \LangB term via the following algorithm:

% \newpage
\newcommand{\Rho}{\mathrm{P}}
\newcommand{\expandsTo}{\rightsquigarrow}
\newcommand{\macroHole}[2]{\Box_{#1 ; #2}}

% TODO: transition
In the following rules, $\Gamma$ is the type macro-context which associates
variables to Haskell types, and $\Rho$ is the recursion context which associates
arguments of the top-level declaration to a type macro-context.

\begin{figure*}
{\centering
\[
\begin{array}{c}
  \Gamma \vdash x : \alpha \\
  \Rho \ni x \mapsto \varnothing \\
  \Gamma_i := (\Gamma \cup \{\overline{y_{i,j}:\beta_{i,j}}\}) \setminus \{x:\alpha\} \\
  \Rho_i := \Rho[ x \mapsto \{\overline{y_{i,j}:\beta_{i,j}}\} ] \\
  \hline \\[-1em] 
  \Gamma; \Rho 
  \vdash
  \macro{induct} ~ x
  \expandsTo 
  \MC{case} ~ x ~ \MC{of} ~ 
  \overline{
    c_i ~ \overline{y_{i,j}} ~ \rightarrow ~ 
    \macroHole
      {\Gamma_i}
      {\Rho_i};
  }
\\[1em]
  \Gamma \vdash e : \alpha \\
  \alpha ~ \text{has constructors} ~ \overline{c_i : \overline{\beta_{i,j} \rightarrow} ~ \alpha} \\
  \Gamma_i := \Gamma \cup \{\overline{y_{i,j}:\beta_{i,j}}\} \\
  \hline \\[-1em] 
  \Gamma; \Rho
  \vdash
  \macro{destruct} ~ e
  \expandsTo 
  \MC{case} ~ e ~ \MC{of} ~
  \overline{
    c_i ~ \overline{y_{i,j}} ~ \rightarrow ~ 
    \macroHole
      {\Gamma_i}
      {\Rho};
  }
\\[1em]
  \Gamma \vdash e:\MC{Bool} \\
  \hline
  \Gamma; \Rho
  \vdash
  \macro{condition} ~ e
  \expandsTo
  \MC{if} ~ e ~ \MC{then} ~ \macroHole{\Gamma}{\Rho} ~ \MC{else} ~ \macroHole{\Gamma}{\Rho}
\\[1em]
  \Gamma \vdash e:\MC{Bool} \\
  \hline
  \Gamma; \Rho
  \vdash
  \macro{assert} ~ e
  \expandsTo
  \MC{if} ~ e ~ \MC{then} ~ \macroHole{\Gamma}{\Rho} ~ \MC{else} ~ \MC{trivial}
\\[1em]
  \Gamma \vdash e:\MC{Bool} \\
  \hline
  \Gamma; \Rho
  \vdash
  \macro{dismiss} ~ e
  \expandsTo
  \MC{if} ~ e ~ \MC{then} ~ \MC{trivial} ~ \MC{else} ~ \macroHole{\Gamma}{\Rho}
\\[1em]
  \Gamma \vdash \overline{a_i:A_i} \\
  n \in \mathbb{N} \\
  \hline 
  \Gamma; \Rho
  \vdash 
  \macro{auto} ~ [\overline{_i}] ~ n
  \expandsTo
  \mathsf{auto}(\Gamma, \Rho, \overline{a_i}, n) ~ \MC{\&\&\&} ~ \macroHole{\Gamma}{\Rho}
\\[1em]
  \Gamma \vdash e : \MC{Proof} \\
  \hline
  \Gamma; \Rho
  \vdash 
  \macro{use} ~ \{ e \} 
  \expandsTo
  e ~ \MC{\&\&\&} ~ \macroHole{\Gamma}{\Rho}
\\[1em]
  \hline
  \Gamma; \Rho
  \vdash
  \macro{trivial}
  \expandsTo
  \MC{trivial}
\end{array}
\]
}
\caption{Proof macro semantics}
\label{fig:proof-macro-semantics}
\end{figure*}

\todo{how to properly reference this}
Recall the proof macro used to prove \LC{elem_concat}.
The macro declaration begins with a type signature and then \LC{elem_concat x xs ys}.
From the type signature, the proof macro system can deduce the types of \LC{x}, \LC{xs}, and \LC{ys} and bring these variables into context.
\footnote{Unfortunately, types of local bindings cannot be inferred wiht Template Haskell, so the type signature is in fact necessary.}
% TODO: (elem x ys) should be {elem x ys}, but causes {too many {}} error
The sequence of proof macros begins with \LC{assert (elem x ys)}, which conditions on \LC{elem x ys} and then fills with \LC{else} case with \LC{trivial}.
The last proof macro is \LC{induct xs}, which pattern matches on \LC{xs} into 2 macro-processing branching: \LC{[]} and \LC{x':xs'}.
\footnote{In the implementation, these fresh variables are given unique suffixes, but this unecessarily intrudes on readability.}
In the second branch, the variables \LC{x'} and \LC{xs'} are added to the recursion context for the 2nd argument position, since \LC{xs} is in the 2nd argument position.
Finally, since the last proof macro was \textit{not} an evidence macro, a \LC{auto} is implicitly appended.
This \LC{auto} is processed in each branch resulting from \LC{induct xs}.
In the branch for \LC{[]}, the only values in scope are \LC{x} and \LC{ys}, so there are no neutral forms to generate.
The recursion \LC{elem_concat x ys ys} is not generated because none of the arguments are from the recursion context of their respective argument position.
In the branch for \LC{[]}, the values in sccope are \LC{x}, \LC{x'}, \LC{xs'}, and \LC{ys}, so there are several neutral forms that can be generated -- in particular, several recursions:
\begin{itemize}
  \item \LC{elem_concat x' xs' xs'}
  \item \LC{elem_concat x' xs' ys}
  \item \LC{elem_concat x xs' xs'}
  \item \LC{elem_concat x xs' ys}
\end{itemize}
These are valid recursions because all of them have at least one argument from the recursion context at that argument position: \LC{xs'}.
Altogether, the resulting \LangBTerm is the following:
\begin{code}
  elem_concat :: N -> [N] -> [N] -> Proof
  elem_concat = \x xs ys ->
    if elem x ys then
      case xs of
        Nil -> trivial
        Cons x' xs' -> Auto
          { init = [ elem_concat x' xs' xs' 
                   , elem_concat x' xs' ys
                   , elem_concat x  xs' xs'
                   , elem_concat x  xs' ys ]
          , kept = []
          , pruned = [] }
    else
      trivial
\end{code}
Here, the \LC{Auto} structure corresponds to the term
\begin{code}
  elem_concat x' xs' xs' &&&
  elem_concat x' xs' ys  &&&
  elem_concat x  xs' xs' &&&
  elem_concat x  xs' ys
\end{code}
with the additional metadata that no terms have been \textit{kept} (i.e. determined to be not safely pruned) and \textit{pruned} (i.e. determined to be safely pruned).

Of course, it turns out that not all of these terms are needed for a valid proof.
The pruning process, described in the next subsection, describes how the \LC{Auto} structure's metadata is used statefully to safely prune the unnecessary terms.
  
\subsection{Pruning}

\subsubsection{Linear Pruning}

For each \LC{Auto} structure in a \LangBTerm, each \textit{exp} in its \LC{init} field is attempted to be pruned one at a time.
This is done by moving the \textit{exp} from the \LC{init} field to the \LC{pruned} field, embedding and splicing the new \LangBTerm into the original Haskell file in place of the original proof macro, and then running Liquid Haskell to check if this prune was safe.
If it was then pruning continues with the rest of the \textit{exp}s in the \LC{init} fields of the \LC{Auto} structures, otherwise this prune is undone, and the \textit{exp} that was attempted to be pruned is instead moved to the \LC{kept} field before continuing pruning.

Recall the \LangBTerm that resulted from processing the proof macro used to prove \LC{elem_concat}.
There is an \LC{Auto} structure that clearly has a few \textit{exp}s that can be pruned since they are unnecessary for the proof.
The subset of necessary \textit{exp}s is found via the linear pruning procedure, trying to remove each \textit{exp} one at a time to see which can be safely removed.
After pruning, the final resulting \LangBTerm can be embedded into Haskell a last time and presented to the user as a valid proof:

\begin{code}
  elem_concat :: N -> [N] -> [N] -> Proof
  elem_concat = \x xs ys ->
    if elem x ys then
      case xs of
        Nil -> trivial
        Cons x' xs' -> elem_concat x xs' ys
    else
      trivial
\end{code}

\todo{onclusion of Linear Pruning subsection}

\todo{pretty sure this shouldn't be included}
\subsubsection{Superlinear Pruning}

Since the set of \textit{exp}s that can be safely pruned is an arbitrary subset of all the \textit{exp}s in \LC{Auto} structures in a \LangBTerm, given the information available at this stage, it is impossible to achieve generally superlinear pruning runtime. 
However, very often the size of the subset of \textit{exp}s that need to be kept is constant size -- around 1-4.
So in practice it may be feasible to perform a sort of binary search.
\todo{describe more?}

\section*{Temporary}

\todo{where to put this?}
Note that, for Liquid Haskell, the refinement of the type of \LC{f x y, trivial)} is the same as the refinement of the type of \LC{f x y}.
So, the refinement of the expression's type can be included into the refinement context by simply adding it into the resulting Haskell expression

% \todo{where to put this? i have a different example i used for this section, so do I need to bring back \LC{assoc\_min} again?}
The proof of \LC{assoc\_min} can be expressed shortly as follows:
  
 The "induct a" macro does case analsis on "a", resulting in two branches. Since both branches are to be handled, the following two macros are executed in both branches (matching the behavior of the ";" tactic combinator in Coq).
 Additionally, in the "S a'" case, the "induct a" tactic notices that "a'" was introduced by inducting on an input variable term in positon 0, so "a'" is marked as a valid argument to a recursive call to "assoc\_min" in position 0.
 The same happens for "induct b" and "induct c", yielding the same branches of the verbose Haskell term.
 Finally, every proof macro implicitly ends with "auto" unless it ends with "trivial" or "use e".
 So, in each of the 9 branches, "auto" is executed to generate all well-typed terms of type "Proof" using things in local context.
 In all but the "S a', S b', S c'" case, there are no such well-typed applications, since the only way to produce a term of type "Proof" is to use "assoc\_min", but only in that final is there a term in context that is available to use as the argument to a recursive call to "assoc\_min", for each of its argment positions (which are 0, 1, 2 since it has 3 arguments and each is inducted on).
  
