\section{Introduction}

Liquid Haskell\cite{liquidHaskell} is a popular verifier for Haskell
programs, leveraging the power of SMT solvers~\cite{BarST-RR-10} like
Z3~\cn and CVC4\cn to prove the correctness of diverse applications
ranging from optimizations~\cite{TPE2018} to string matching
algorithms~\cite{TaleOfTwoProvers}. Specifications for these
applications are written in the form of {\em refinement
  types}\cite{RefinementForML}, boolean predicates over program
values.

For concreteness, consider the following \LC{min} function that
computes the minimum of two natural numbers (\LC{N}):
\begin{code}
  min :: N -> N -> N 
  min Z _ = Z
  min _ Z = Z
  min (S m) (S n) = S (min m n)
\end{code}

\newcommand{\imin}{\textit{min}~}
Naturally, we would expect such a function to be associative, that is:
$$ \forall a ~ b ~ c. ~ \imin (\imin a~b) == \imin a~(\imin~b~c) $$
%
In Liquid Haskell, we can express associativity by defining a
refinement type to encode this property, and prove it by defining
a term of the following type:
%
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
      {_:() | min (min a b) c == min a (min b c)}
  @-}
  assoc_min :: N -> N -> N -> Proof
  assoc_min a b c = ...
\end{code}
%
The Haskell type of \LC{assoc_min} is a function with three natural
number arguments that returns a \LC{Proof}, which (to GHC) is just a
type synonym for \LC{()}. The Liquid Haskell type of \LC{assoc_min},
however, is much more interesting: its return type does not only
specify that the output is a unit, but {\em refines} it so that
associativity of \LC{min} holds for its input arguments. In other
words, the only interesting thing about the result of this function
is its refinement, which constitutes an ``extrinsic style'' proof
of associativity. This is a common enough pattern that Liquid Haskell
supports dropping the ``\LC{_:()}'' part of the refinement for brevity,
as we will also do in the remainder of this paper.

But how does Liquid Haskell decide if the refinement type is true? By
reducing typechecking to verification conditions that SMT solvers
reason about. However, while SMT solvers are pre-programmed with a
wide assortment of facts about various domains such as integer
arithmetic and boolean logic, they don't really know anything about
user-defined data types like \LC{N} or user-defined functions like
\LC{min}. To that end, Liquid Haskell lifts user-defined data types
and functions into a representation that can be handled symbolically
by SMT solvers~\cite{VazouTCSNWJ18}. Still, many true properties of
user-defined data types and functions are still not automatically
verifiable: users must guide, via refined Haskell code, the SMT solver
to simpler cases that can be checked automatically.

Unfortunately, given the lack of interactivity of Liquid Haskell, it
is not always clear what the gap in understanding between the user and
the SMT solver is, which often makes writing such refined code a
tedious and frustrating process. Consider again associativity for the
\LC{min} function. On paper, we can informally reason that
associativity holds by induction on the natural numbers that are inputs
to \LC{min}, due to its simple recursive structure. In Liquid Haskell,
the refined code that finally convinces the SMT solver that the
program typechecks is shown in Figure~\ref{fig:assoc-min-proof}.


% The SMT solver, however, does not know about induction (unlike Coq where a tactic "induction" could solve this goal right away).
% And, because of Liquid Haskell's limited capabilities for quantifying over predicates (TODO: include reference here), it is unfeasible to write the induction principle for natural numbers as a refined Haskell function.
% So, a proof of "assoc\_min" is written as follows:
\begin{figure}
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
        {min (min a b) c == min a (min b c)} @-}
  assoc_min :: N -> N -> N -> Proof
  assoc_min a b c =
    case a of 
      Z ->
        case b of 
          Z ->
            case c of
              Z -> trivial
              S c' -> trivial
          S b' ->
            case c of
              Z -> trivial
              S c' -> trivial
    S a' ->
      case b of 
        Z ->
          case c of
            Z -> trivial
            S c' -> trivial
        S b' ->
          case c of
            Z -> trivial
            S c' -> assoc_min a' b' c'
\end{code}
\caption{Liquid Haskell proof term for associativity of \texttt{min}}
\label{fig:assoc-min-proof}
\end{figure}

{\em All} of the branches of pattern matching on \LC{a}, \LC{b}, and \LC{c}
must be written out explicitly. Otherwise, the SMT solver would not
know how to simplify the \LC{min} expressions in the refinement---the
only facts it knows are the three equations that were used to define
\LC{min}: \LC{min Z _ = Z}, \LC{min _ Z = Z}, and
%
\LC{min (S x) (S y) = S (min x y)}.
%
Liquid Haskell understands the constraints introduced by this case analysis,
and takes them into account in order to discharge most cases---the non-recursive
ones that involve at least one \LC{Z}. The proof conclusion in such cases is \LC{trivial},
which is again just a synonym for the term-level \LC{()}.

However, in the recursive case of \LC{min}, the Liquid Haskell typechecker needs
additional help, in the form of a recursive call to \LC{assoc_min a' b' c'}, which
brings its refinement in scope for the SMT solver and allows it to conclude that
the induced verification condition holds. Crucially, this refinement is again the
only thing that matters: while the structure of the term gives the appearance
of a proof term in the style of Coq or Agda, the actual return value doesn't matter.
We could just as well have written something like
\begin{code}
  snd (assoc_min a' b' c', ())
\end{code}
and Liquid Haskell would still gladly accept the definition. In fact,
Liquid Haskell's conjunction operator (\LC{&&&}) is defined exactly
this way: it takes two \LC{Proof}s and returns the second one---its
only effect is making the refinement of both arguments visible to the SMT solver.

Even in this simple example of associativity of \LC{min}, the full
verbosity required is cumbersome and obscures the fact that the
underlying argument is a straightforward induction. In larger
developments where the SMT solver might need to rely on helper lemmas,
this problem only becomes more pronounced.  Other proof assistants,
such as Coq or Lean, unconstrained by the maturity and complexity of
an ecosystem like Haskell's, rely on interactive tactics in these
situations to aid users' proof efforts.

\smallskip

{\em What can we do within the confines of the existing Haskell
  ecosystem to aid users?}
  Without interactivity, an interface to concise proof generators must expand to
  a proof term all at once i.e. a macro. So, we developed an macro
  system for generating Liquid Haskell proof terms, using existing
  metaprogramming tools for Haskell.
  % TODO: any other limitations to mention, that directed us to this solution?

\paragraph*{Liquid Proof Macros}

In this paper, we show how to leverage the power of Template Haskell
to automate proof term generation for Liquid Haskell.  We develop {\em
  Liquid Proof Macros}, an extensible DSL in which users can write
intutive proofs that resemble automated tactics%
\footnote{We refrain calling our DSL tactics, as that suggests a
  notion of interactivity that is impossible in the current version
  of Liquid Haskell.}%
%
of more traditional proof assistants, including case analysis,
induction, conditioning, and proof search. The proof of associativity
of \LC{min} using Liquid Proof macros can be seen in
Figure~\ref{fig:assoc-min-macro}.

These macros are then elaborated using Template Haskell to a subset of
Haskell that resembles, or rather is even more complicated than, the
one used in Figure~\ref{fig:assoc-min-proof}. To facilitate
typechecking of larger Liquid Haskell developments, we also augment
this subset with metadata information, and provide a pruning algorithm
reminiscent of shrinking in property-based testing\cn, that simplifies
away any unnecessary components of the proof search process.


\begin{figure}[t]
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
        {min (min a b) c == min a (min b c)} @-}
  [tactic|
    assoc_min :: N -> N -> N -> Proof
    assoc_min a b c = induct a; induct b; induct c
  |]
\end{code}
\caption{Associativity of \texttt{min} using Liquid Proof Macros}
\label{fig:assoc-min-macro}
\end{figure}

In the rest of the paper we make the following contributions:
\begin{itemize}
\item We describe a methodology for using Template Haskell to automatically construct Liquid Haskell proof terms~\ref{sec:impl-dsl}.
\item We develop an extensible framework using this methodology for automating inductive proofs in Liquid Haskell~\ref{sec:impl-framework}.
\item We evaluate our framework against prior work that attempted to
  bring tactic-inspired reasoning in Liquid Haskell~\ref{sec:eval}.
\end{itemize}
We discuss limitations of our work in Section~\ref{sec:limitations}
and related work in Section~\ref{sec:related}, before concluding with
directions for future work~\ref{sec:future}.
