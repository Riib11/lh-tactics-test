\section{Introduction}

Liquid Haskell\cite{liquidHaskell} is a popular verifier for Haskell
programs, leveraging the power of SMT solvers~\cite{BarST-RR-10} like
Z3~\cn and CVC4\cn to prove the correctness of diverse applications
ranging from optimizations~\cite{TPE2018} to string matching
algorithms~\cite{TaleOfTwoProvers}. Specifications for these
applications are written in the form of {\em refinement
  types}\cite{RefinementForML}, boolean predicates over program
values.

For concreteness, consider the following \LC{min} function that
computes the minimum of two natural numbers (\LC{N}):
\begin{code}
  min :: N -> N -> N 
  min Z _ = Z
  min _ Z = Z
  min (S m) (S n) = S (min m n)
\end{code}

\newcommand{\imin}{\textit{min}~}
Naturally, we would expect such a function to be associative, that is:
$$ \forall a ~ b ~ c. ~ \imin (\imin a~b) == \imin a~(\imin~b~c) $$
%
In Liquid Haskell, we can express associativity by defining a
refinement type to encode this property, and prove it by defining
a term of the following type:
%
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
      {_:() | min (min a b) c == min a (min b c)}
  @-}
  assoc_min :: N -> N -> N -> Proof
  assoc_min a b c = ...
\end{code}
%
The Haskell type of \LC{assoc_min} is a function with three natural
number arguments that returns a \LC{Proof}, which (to GHC) is just a
type synonym for \LC{()}. The Liquid Haskell type of \LC{assoc_min},
however, is much more interesting: its return type does not only
specify that the output is a unit, but {\em refines} it so that
associativity of \LC{min} holds for its input arguments. In other
words, the only interesting thing about the result of this function
is its refinement, which constitutes an ``extrinsic style'' proof
of associativity. This is a common enough pattern that Liquid Haskell
supports dropping the ``\LC{_:()}'' part of the refinement for brevity,
as we will also do in the remainder of this paper.

But how does Liquid Haskell decide if the refinement type is true? By
reducing typechecking to verification conditions that SMT solvers
reason about. However, while SMT solvers are pre-programmed with a
wide assortment of facts about various domains such as integer
arithmetic and boolean logic, they don't really know anything about
user-defined data types like \LC{N} or user-defined functions like
\LC{min}. To that end, Liquid Haskell lifts user-defined data types
and functions into a representation that can be handled symbolically
by SMT solvers~\cite{VazouTCSNWJ18}. Still, many true properties of
user-defined data types and functions are still not automatically
verifiable: users must guide, via refined Haskell code, the SMT solver
to simpler cases that can be checked automatically.

Unfortunately, given the lack of interactivity of Liquid Haskell, it
is not always clear what the gap in understanding between the user and
the SMT solver is, which often makes writing such refined code a
tedious and frustrating process. Consider again associativity for the
\LC{min} function. On paper, we can informally reason that
associativity holds by induction on the natural numbers that are inputs
to \LC{min}, due to its simple recursive structure. In Liquid Haskell,
the refined code that finally convinces the SMT solver that the
program typechecks is shown in Figure~\ref{fig:assoc-min-proof}.


% The SMT solver, however, does not know about induction (unlike Coq where a tactic "induction" could solve this goal right away).
% And, because of Liquid Haskell's limited capabilities for quantifying over predicates (TODO: include reference here), it is unfeasible to write the induction principle for natural numbers as a refined Haskell function.
% So, a proof of "assoc\_min" is written as follows:
\begin{figure}
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
        {min (min a b) c == min a (min b c)} @-}
  assoc_min :: N -> N -> N -> Proof
  assoc_min a b c =
    case a of 
      Z ->
        case b of 
          Z ->
            case c of
              Z -> trivial
              S c' -> trivial
          S b' ->
            case c of
              Z -> trivial
              S c' -> trivial
    S a' ->
      case b of 
        Z ->
          case c of
            Z -> trivial
            S c' -> trivial
        S b' ->
          case c of
            Z -> trivial
            S c' -> assoc_min a' b' c'
\end{code}
\caption{Liquid Haskell proof term for associativity of \texttt{min}}
\label{fig:assoc-min-proof}
\end{figure}

{\em All} of the branches of pattern matching on \LC{a}, \LC{b}, and \LC{c}
must be written out explicitly. Otherwise, the SMT solver would not
know how to simplify the \LC{min} expressions in the refinement---the
only facts it knows are the three equations that were used to define
\LC{min}: \LC{min Z _ = Z}, \LC{min _ Z = Z}, and
%
\LC{min (S x) (S y) = S (min x y)}.
%
Liquid Haskell understands the constraints introduced by this case analysis,
and takes them into account in order to discharge most cases---the non-recursive
ones that involve at least one \LC{Z}. The proof conclusion in such cases is \LC{trivial},
which is again just a synonym for the term-level \LC{()}.

However, in the recursive case of \LC{min}, the Liquid Haskell typechecker needs
additional help, in the form of a recursive call to \LC{assoc_min a' b' c'}, which
brings its refinement in scope for the SMT solver and allows it to conclude that
the induced verification condition holds. Crucially, this refinement is again the
only thing that matters: while the structure of the term gives the appearance
of a proof term in the style of Coq or Agda, the actual return value doesn't matter.
We could just as well have written something like
\begin{code}
  snd (assoc_min a' b' c', ())
\end{code}
and Liquid Haskell would still gladly accept the definition.

Even in this simple example of associativity of \LC{min}, the full
verbosity required is cumbersome and obscures the fact that the
underlying argument is a straightforward induction. In larger
developments where the SMT solver might need to rely on helper lemmas,
this problem only becomes more pronounced.  Other proof assistants,
such as Coq or Lean, unconstrained by the maturity and complexity of
an ecosystem like Haskell's, rely on interactive tactics in these
situations to aid users' proof efforts.

\smallskip

{\em What can we do within the confines of the existing Haskell
  ecosystem to aid users?}
% proofs, this problem is even more pronounced suffers
% from the inability of the Liquid Haskell system to fully support
% proof-relevant manipulations (e.g. reasoning about higher-order
% functions/predicates).
% % TODO: explain in more detail the last clause, if relevant enough


\paragraph*{Liquid Proof Macros}

In this paper, we show how to leverage the power of Template Haskell
to automate proof term generation for Liquid Haskell.  We develop {\em
  Liquid Proof Macros}, an extensible DSL in which users can write
intutive proofs that resemble automated tactics%
\footnote{We refrain calling our DSL tactics, as that suggests a
  notion of interactivity that is impossible in the current version
  of Liquid Haskell.}%
%
of more traditional proof assistants, including case analysis,
induction, conditioning, and proof search. The proof of associativity
of \LC{min} using Liquid Proof macros can be seen in
Figure~\ref{fig:assoc-min-macro}.

These macros are then elaborated using Template Haskell to a subset of
Haskell that resembles, or rather is even more complicated than, the
one used in Figure~\ref{fig:assoc-min-proof}. To facilitate
typechecking of larger Liquid Haskell developments, we also augment
this subset with metadata information, and provide a pruning algorithm
reminiscent of shrinking in property-based testing\cn, that simplifies
away any unnecessary components of the proof search process.


\begin{figure}[t]
\begin{code}
  {-@ assoc_min :: a:N -> b:N -> c:N ->
        {min (min a b) c == min a (min b c)} @-}
  [tactic|
    assoc_min :: N -> N -> N -> Proof
    assoc_min a b c = induct a; induct b; induct c
  |]
\end{code}
\caption{Associativity of \texttt{min} using Liquid Proof Macros}
\label{fig:assoc-min-macro}
\end{figure}

In the rest of the paper we make the following contributions:
\begin{itemize}
\item We describe a methodology for using Template Haskell to automatically construct Liquid Haskell proof terms~\ref{sec:impl-dsl}.
\item We develop an extensible framework using this methodology for automating inductive proofs in Liquid Haskell~\ref{sec:impl-framework}.
\item We evaluate our framework against prior work that attempted to
  bring tactic-inspired reasoning in Liquid Haskell~\ref{sec:eval}.
\end{itemize}
We discuss limitations of our work in Section~\ref{sec:limitations}
and related work in Section~\ref{sec:related}, before concluding with
directions for future work~\ref{sec:future}.

% TODO: not sure where to put this (probably should be deleted, since it would have gone here somewhere in the introduction)
% The proof macro system introduced by this paper addresses these concerns and more by providing a macro interface to the user that allows them to concisely express terms of the subset of Haskell code that is useful for writing these SMT guides through Haskell control flow.
  
%  The proof macro system defines a DSL that can be written in ``tactic'' quasiquotes, and then this DSL term is expanded to the verbose Haskell term after type checking and pruning (to be explained soon).
  
%  The overarching idea behind the proof macro system is that an extrinsic proof has the following structure, involving two kinds of components:
%  I. match control flow (e.g. conditions, cases, anything that adds information to the refinement context) of some functions that appear in the specification
%  II. at each leaf of the resulting control-flow structure, use some lemmas and/or recursions to provide enough information to the refinement context that the SMT can automatically check that leaf's goal.
  

% TODO: some other examples to consider analyzing. I know the "assoc_min" example is particularly simple, but it does very much display the conciseness advantage, and doesn't have to use any lemmas

% -- prop15_lemma
%  
% {-@ reflect prop15_lemma @-}
% prop15_lemma :: N -> N -> ListN -> Bool
% prop15_lemma n x l = lengthListN (insertListN n l) == lengthListN (Cons x l)
%  
% return []
%  
% {-@ automatic-instances prop15_lemma_proof @-}
% {-@
% prop15_lemma_proof :: n:N -> x:N -> l:ListN -> {prop15_lemma n x l}
% @-}
% -- %tactic:begin:prop15_lemma_proof
% prop15_lemma_proof :: N -> N -> ListN -> Proof
% prop15_lemma_proof = \n -> \x -> \l -> case l of
%                                            Data.Nil -> trivial
%                                            Data.Cons n_0 listN_1 -> prop15_lemma_proof n x listN_1
% -- %tactic:end:prop15_lemma_proof
%  
% -- [tactic|
% -- prop15_lemma_proof :: N -> N -> ListN -> Proof
% -- prop15_lemma_proof n x l =
% --   induct l
% -- |]
%  
% -- prop15
%  
% {-@ reflect prop15 @-}
% prop15 :: N -> ListN -> Bool
% prop15 n l = lengthListN (insertListN n l) == S (lengthListN l)
%  
% return []
%  
% {-@ automatic-instances prop15_proof @-}
% {-@
% prop15_proof :: n:N -> l:ListN -> {prop15 n l}
% @-}
% -- %tactic:begin:prop15_proof
% prop15_proof :: N -> ListN -> Proof
% prop15_proof = \n -> \l -> case l of
%                                Data.Nil -> trivial
%                                Data.Cons n_0 listN_1 -> prop15_proof n listN_1
% -- %tactic:end:prop15_proof
%  
% -- [tactic|
% -- prop15_proof :: N -> ListN -> Proof
% -- prop15_proof n l =
% --   induct l;
% --   auto [prop15_lemma_proof]
% -- |]
%  
% -- prop20_lemma
%  
% {-@ reflect prop20_lemma @-}
% prop20_lemma :: N -> ListN -> Bool
% prop20_lemma h t = lengthListN (insertListN h (sortListN t)) == S (lengthListN (sortListN t))
%  
% return []
%  
% {-@
% prop20_lemma_proof :: h:N -> l:ListN -> {prop20_lemma h l}
% @-}
% prop20_lemma_proof :: N -> ListN -> Proof 
% prop20_lemma_proof h l = undefined
%  
% -- prop20
%  
% {-@ reflect prop20 @-}
% prop20 :: ListN -> Bool
% prop20 l = lengthListN (sortListN l) == lengthListN l
%  
% return []
%  
% {-@ automatic-instances prop20_proof @-}
% {-@
% prop20_proof :: l:ListN -> {prop20 l}
% @-}
% -- %tactic:begin:prop20_proof
% prop20_proof :: ListN -> Proof
% prop20_proof = \l -> case l of
%                          Data.Nil -> trivial
%                          Data.Cons n_0
%                                    listN_1 -> prop20_proof listN_1 &&& prop20_lemma_proof n_0 listN_1
% -- %tactic:end:prop20_proof
%  
% -- [tactic|
% -- prop20_proof :: ListN -> Proof
% -- prop20_proof l =
% --   induct l;
% --   auto [prop20_lemma_proof]
% -- |]
%  
% % prop 24
%  
% {-@ reflect prop @-}
% prop a b = ((maxN a b) == a) == (leqN b a)
%  
% {-@ automatic-instances proof @-}
% {-@
% proof :: a:N -> b:N -> {prop a b}
% @-}
% -- [tactic|
% -- proof :: N -> N -> Proof
% -- proof a b = induct a; induct b
% -- |]
% -- %tactic:begin:proof
% proof :: N -> N -> Proof
% proof = \a -> \b -> case a of
%                         Data.Z -> case b of
%                                       Data.Z -> trivial
%                                       Data.S n_0 -> trivial
%                         Data.S n_0 -> case b of
%                                           Data.Z -> trivial
%                                           Data.S n_1 -> proof n_0 n_1
% -- %tactic:end:proof
%  
% % prop27
%  
% module TIP.Prop27 where
%  
% import Data
% import Proof
% import Tactic.Core.Quote
%  
% {-@ reflect prop @-}
% prop x xs ys = 
%   if elemListN x ys then 
%     elemListN x (concatListN xs ys)
%   else 
%     True
%  
% {-@ automatic-instances proof @-}
% {-@
% proof :: x:N -> xs:ListN -> ys:ListN -> {prop x xs ys}
% @-}
% -- elemListN x1 (concatListN (Cons x2 xs) ys)
% -- elemListN x1 (Cons x2 (concatListN xs ys))
% -- if x1 == x2 then 
% --   QED
% -- else
% --   elemListN x1 (concatListN xs ys)
% -- [tactic|
% -- proof :: N -> ListN -> ListN -> Proof
% -- proof x xs ys =
% --   induct xs;
% --   condition {elemListN x ys}
% -- |]
% -- %tactic:begin:proof
% proof :: N -> ListN -> ListN -> Proof
% proof = \x -> \xs -> \ys -> case xs of
%                                 Data.Nil -> if elemListN x ys then trivial else trivial
%                                 Data.Cons n_0 listN_1 -> if elemListN x ys
%                                                           then proof x listN_1 ys
%                                                           else trivial
% -- %tactic:end:proof
%  
% % prop31
%  
% {-@ reflect prop @-}
% prop a b c = minN (minN a b) c == minN a (minN b c)
%  
% {-@ automatic-instances proof @-}
% {-@
% proof :: a:N -> b:N -> c:N -> {prop a b c}
% @-}
% -- [tactic|
% -- proof :: N -> N -> N -> Proof
% -- proof a b c = induct a; induct b; induct c
% -- |]
% -- %tactic:begin:proof
% proof :: N -> N -> N -> Proof
% proof = \a -> \b -> \c -> case a of
%                               Data.Z -> case b of
%                                             Data.Z -> case c of
%                                                           Data.Z -> trivial
%                                                           Data.S n_0 -> trivial
%                                             Data.S n_0 -> case c of
%                                                               Data.Z -> trivial
%                                                               Data.S n_1 -> trivial
%                               Data.S n_0 -> case b of
%                                                 Data.Z -> case c of
%                                                               Data.Z -> trivial
%                                                               Data.S n_1 -> trivial
%                                                 Data.S n_1 -> case c of
%                                                                   Data.Z -> trivial
%                                                                   Data.S n_2 -> proof n_0 n_1 n_2
% -- %tactic:end:proof
%  
% -- prop47_lemma
%  
% {-@ reflect prop47_lemma @-}
% prop47_lemma :: N -> N -> Bool
% prop47_lemma m n = maxN m n == maxN n m
%  
% return []
%  
% {-@ automatic-instances prop47_lemma_proof @-}
% {-@
% prop47_lemma_proof :: m:N -> n:N -> {prop47_lemma m n}
% @-}
% prop47_lemma_proof :: N -> N -> Proof
% prop47_lemma_proof m n = undefined
%  
% -- prop47
%  
% {-@ reflect prop47 @-}
% prop47 :: TreeN -> Bool
% prop47 t = heightTreeN t == heightTreeN (mirrorTreeN t)
%  
% return []
%  
% {-@ automatic-instances prop47_proof @-}
% {-@
% prop47_proof :: t:TreeN -> {prop47 t}
% @-}
% -- %tactic:begin:prop47_proof
% prop47_proof :: TreeN -> Proof
% prop47_proof = \t -> case t of
%                          Data.Leaf -> trivial
%                          Data.Node n_0
%                                    treeN_1
%                                    treeN_2 -> prop47_proof treeN_2 &&& (prop47_proof treeN_1 &&& prop47_lemma_proof (heightTreeN treeN_2) (heightTreeN treeN_1)) 
%                                    -- * finds even more efficient proof than I thought of!
% -- %tactic:end:prop47_proof
%  
% -- [tactic|
% -- prop47_proof :: TreeN -> Proof
% -- prop47_proof t = induct t; auto [prop47_lemma_proof, heightTreeN, mirrorTreeN] 3
% -- |]
%  
% % prop52
%  
% {-@ automatic-instances lemma @-}
% {-@
% lemma :: n:N -> xs:ListN -> ys:ListN -> {countListN n (concatListN xs ys) == countListN n (concatListN ys xs)}
% @-}
% lemma :: N -> ListN -> ListN -> Proof
% lemma n xs ys = undefined
%  
% return []
%  
% -- * takes 3m47s to prune
% {-@ automatic-instances proof @-}
% {-@
% proof :: n:N -> xs:ListN -> {countListN n xs == countListN n (reverseListN xs)}
% @-}
% -- %tactic:begin:proof
% proof :: N -> ListN -> Proof
% proof = \n -> \xs -> case xs of
%                          Data.Nil -> trivial
%                          Data.Cons n_0
%                                    listN_1 -> proof n listN_1 &&& lemma n (singletonListN n_0) (reverseListN listN_1)
% -- %tactic:end:proof
% -- [tactic|
% -- proof :: N -> ListN -> Proof
% -- proof n xs =
% --   induct xs;
% --   auto [lemma, reverseListN, singletonListN] 3
% -- |]
%  
% % prop68
%  
% {-@
% lemma1 :: a:N -> b:N -> c:N -> {(leqN a b && leqN b c) => leqN a c}
% @-}
% lemma1 :: N -> N -> N -> Proof
% lemma1 a b c = undefined
%  
% {-@ lemma2 :: a:N -> {leqN a (S a)} @-}
% lemma2 :: N -> Proof 
% lemma2 = undefined
%  
% return []
%  
% {-@ reflect prop @-}
% prop x ys = lengthListN (deleteListN x ys) `leqN` lengthListN ys
%  
% {-@ automatic-instances proof @-}
% {-@
% proof :: x:N -> ys:ListN -> {prop x ys}
% @-}
% -- [tactic|
% -- proof :: N -> ListN -> Proof
% -- proof x ys =
% --   induct ys as [/y ys'];
% --   condition {x == y} requires [y];
% --   use {lemma1 (lengthListN (deleteListN x ys')) (lengthListN ys') (lengthListN ys)} requires [y, ys'];
% --   auto [lemma2, lengthListN]
% -- |]
% -- %tactic:begin:proof
% proof :: N -> ListN -> Proof
% proof = \x -> \ys -> case ys of
%                          Data.Nil -> trivial
%                          Data.Cons y ys' -> if x == y
%                                              then lemma1 (lengthListN (deleteListN x ys')) (lengthListN ys') (lengthListN ys) &&& (proof y ys' &&& lemma2 (lengthListN ys'))
%                                              else lemma1 (lengthListN (deleteListN x ys')) (lengthListN ys') (lengthListN ys) &&& proof x ys'
% -- %tactic:end:proof
