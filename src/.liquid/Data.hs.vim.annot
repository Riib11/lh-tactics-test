1:1-1:1::Data.$trModule :: "GHC.Types.Module"
14:1-14:5::Data.addN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == addN x1 x2}"
14:8-14:9::n :: "Data.N"
14:12-14:13::n :: "{v : Data.N | v == n}"
15:16-15:28::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
15:18-15:28::lq_anf$##7205759403792803388 :: "{v : Data.N | v == addN m n}"
15:24-15:25::m :: "{v : Data.N | v == m}"
15:26-15:27::n :: "{v : Data.N | v == n}"
19:1-19:5::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
19:8-19:9::n :: "Data.N"
19:12-19:13::Data.Z :: "{v : Data.N | v == Z}"
20:12-20:13::ds_d2wi :: "Data.N"
21:20-21:28::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
21:25-21:26::m :: "{v : Data.N | v == m}"
21:27-21:28::n :: "{v : Data.N | v == n}"
25:1-25:5::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
25:8-25:9::n :: "Data.N"
25:12-25:16::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
26:16-26:21::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
27:20-27:28::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
27:25-27:26::m :: "{v : Data.N | v == m}"
27:27-27:28::n :: "{v : Data.N | v == n}"
38:1-38:9::Data.concatNL :: "x1:Data.NL -> x2:Data.NL -> {VV : Data.NL | VV == concatNL x1 x2}"
38:14-38:16::l2 :: "Data.NL"
38:19-38:21::l2 :: "{v : Data.NL | v == l2}"
39:27-39:50::Data.Cons :: "x1:Data.N -> x2:Data.NL -> {v : Data.NL | v == Cons x1 x2\n                                          && lqdc##$select v == x1\n                                          && lqdc##$select v == x2}"
39:32-39:33::h :: "{v : Data.N | v == h}"
39:34-39:50::lq_anf$##7205759403792803400 :: "{v : Data.NL | v == concatNL l1 l2}"
39:44-39:46::l1 :: "{v : Data.NL | v == l1}"
39:47-39:49::l2 :: "{v : Data.NL | v == l2}"
43:1-43:7::Data.takeNL :: "x1:Data.N -> x2:Data.NL -> {VV : Data.NL | VV == takeNL x1 x2}"
43:16-43:19::Data.Nil :: "{v : Data.NL | v == Nil}"
44:14-44:17::Data.Nil :: "{v : Data.NL | v == Nil}"
45:27-45:46::Data.Cons :: "x1:Data.N -> x2:Data.NL -> {v : Data.NL | v == Cons x1 x2\n                                          && lqdc##$select v == x1\n                                          && lqdc##$select v == x2}"
45:32-45:33::h :: "{v : Data.N | v == h}"
45:34-45:46::lq_anf$##7205759403792803405 :: "{v : Data.NL | v == takeNL n l}"
45:42-45:43::n :: "{v : Data.N | v == n}"
45:44-45:45::l :: "{v : Data.NL | v == l}"
49:1-49:7::Data.dropNL :: "x1:Data.N -> x2:Data.NL -> {VV : Data.NL | VV == dropNL x1 x2}"
49:16-49:19::Data.Nil :: "{v : Data.NL | v == Nil}"
50:23-50:31::Data.Cons :: "x1:Data.N -> x2:Data.NL -> {v : Data.NL | v == Cons x1 x2\n                                          && lqdc##$select v == x1\n                                          && lqdc##$select v == x2}"
50:28-50:29::h :: "{v : Data.N | v == h}"
50:30-50:31::l :: "{v : Data.NL | v == l}"
51:27-51:37::Data.dropNL :: "x1:Data.N -> x2:Data.NL -> {VV : Data.NL | VV == dropNL x1 x2}"
51:34-51:35::n :: "{v : Data.N | v == n}"
51:36-51:37::l :: "{v : Data.NL | v == l}"
55:1-55:8::Data.countNL :: "x1:Data.N -> x2:Data.NL -> {VV : Data.N | VV == countNL x1 x2}"
55:9-55:10::n :: "Data.N"
55:17-55:18::Data.Z :: "{v : Data.N | v == Z}"
56:24-56:71::lq_anf$##7205759403792803458 :: "{v : GHC.Types.Bool | (v <=> n == h)\n                      && v == == n h}"
56:27-56:28::n :: "{v : Data.N | v == n}"
56:32-56:33::h :: "{v : Data.N | v == h}"
56:39-56:54::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
56:41-56:54::lq_anf$##7205759403792803459 :: "{v : Data.N | v == countNL n l}"
56:50-56:51::n :: "{v : Data.N | v == n}"
56:52-56:53::l :: "{v : Data.NL | v == l}"
56:60-56:71::Data.countNL :: "x1:Data.N -> x2:Data.NL -> {VV : Data.N | VV == countNL x1 x2}"
56:68-56:69::n :: "{v : Data.N | v == n}"
56:70-56:71::l :: "{v : Data.NL | v == l}"