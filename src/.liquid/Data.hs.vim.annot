1:1-1:1::Data.$trModule :: "GHC.Types.Module"
8:1-8:8::Data.implies :: "x1:GHC.Types.Bool -> x2:GHC.Types.Bool -> {VV : GHC.Types.Bool | VV == implies x1 x2\n                                                                 && VV == (if x1 then x2 else true)}"
8:9-8:10::p :: "GHC.Types.Bool"
8:11-8:12::q :: "GHC.Types.Bool"
8:18-8:19::_ :: "{v : GHC.Types.Bool | v == p}"
8:25-8:26::q :: "{v : GHC.Types.Bool | v == q}"
8:32-8:36::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
20:1-20:9::Data.n_to_int :: "Data.N -> {v : GHC.Types.Int | 0 <= v}"
20:14-20:15::lq_anf$##7205759403792804660 :: "{v : GHC.Prim.Int# | v == 0}"
21:18-21:19::lq_anf$##7205759403792804662 :: "GHC.Types.Int"
21:22-21:32::lq_anf$##7205759403792804663 :: "{v : GHC.Types.Int | v == n_to_int n\n                     && 0 <= v}"
21:31-21:32::n :: "{v : Data.N | v == n}"
25:1-25:5::Data.addN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == addN x1 x2}"
25:8-25:9::n :: "Data.N"
25:12-25:13::n :: "{v : Data.N | v == n}"
26:16-26:28::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
26:18-26:28::lq_anf$##7205759403792804490 :: "{v : Data.N | v == addN m n}"
26:24-26:25::m :: "{v : Data.N | v == m}"
26:26-26:27::n :: "{v : Data.N | v == n}"
30:1-30:5::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
30:8-30:9::n :: "Data.N"
30:12-30:13::Data.Z :: "{v : Data.N | v == Z}"
31:12-31:13::ds_d2NN :: "Data.N"
32:20-32:28::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
32:25-32:26::m :: "{v : Data.N | v == m}"
32:27-32:28::n :: "{v : Data.N | v == n}"
36:1-36:5::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
36:8-36:9::n :: "Data.N"
36:12-36:16::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
37:16-37:21::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
38:20-38:28::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
38:25-38:26::m :: "{v : Data.N | v == m}"
38:27-38:28::n :: "{v : Data.N | v == n}"
42:1-42:4::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
42:7-42:8::n :: "Data.N"
42:11-42:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
43:11-43:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
44:19-44:26::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
44:23-44:24::m :: "{v : Data.N | v == m}"
44:25-44:26::n :: "{v : Data.N | v == n}"
48:1-48:5::Data.maxN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == maxN x1 x2}"
48:8-48:9::n :: "Data.N"
48:12-48:13::n :: "{v : Data.N | v == n}"
49:12-49:13::ds_d2MQ :: "Data.N"
50:20-50:32::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
50:22-50:32::lq_anf$##7205759403792804522 :: "{v : Data.N | v == maxN m n}"
50:28-50:29::m :: "{v : Data.N | v == m}"
50:30-50:31::n :: "{v : Data.N | v == n}"
61:1-61:12::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
61:17-61:19::l2 :: "Data.ListN"
61:22-61:24::l2 :: "{v : Data.ListN | v == l2}"
62:30-62:56::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
62:35-62:36::h :: "{v : Data.N | v == h}"
62:37-62:56::lq_anf$##7205759403792804530 :: "{v : Data.ListN | v == concatListN l1 l2}"
62:50-62:52::l1 :: "{v : Data.ListN | v == l1}"
62:53-62:55::l2 :: "{v : Data.ListN | v == l2}"
66:1-66:10::Data.takeListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == takeListN x1 x2}"
66:19-66:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
67:17-67:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
68:30-68:52::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
68:35-68:36::h :: "{v : Data.N | v == h}"
68:37-68:52::lq_anf$##7205759403792804535 :: "{v : Data.ListN | v == takeListN n l}"
68:48-68:49::n :: "{v : Data.N | v == n}"
68:50-68:51::l :: "{v : Data.ListN | v == l}"
72:1-72:10::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
72:19-72:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
73:26-73:34::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
73:31-73:32::h :: "{v : Data.N | v == h}"
73:33-73:34::l :: "{v : Data.ListN | v == l}"
74:30-74:43::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
74:40-74:41::n :: "{v : Data.N | v == n}"
74:42-74:43::l :: "{v : Data.ListN | v == l}"
78:1-78:11::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
78:12-78:13::n :: "Data.N"
78:20-78:21::Data.Z :: "{v : Data.N | v == Z}"
79:27-79:80::lq_anf$##7205759403792804704 :: "{v : GHC.Types.Bool | (v <=> n == h)\n                      && v == == n h}"
79:30-79:31::n :: "{v : Data.N | v == n}"
79:35-79:36::h :: "{v : Data.N | v == h}"
79:42-79:60::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
79:44-79:60::lq_anf$##7205759403792804705 :: "{v : Data.N | v == countListN n l}"
79:56-79:57::n :: "{v : Data.N | v == n}"
79:58-79:59::l :: "{v : Data.ListN | v == l}"
79:66-79:80::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
79:77-79:78::n :: "{v : Data.N | v == n}"
79:79-79:80::l :: "{v : Data.ListN | v == l}"
83:1-83:12::Data.lengthListN :: "x1:Data.ListN -> {VV : Data.N | VV == lengthListN x1}"
83:19-83:20::Data.Z :: "{v : Data.N | v == Z}"
84:26-84:43::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
84:28-84:43::lq_anf$##7205759403792804547 :: "{v : Data.N | v == lengthListN t}"
84:41-84:42::t :: "{v : Data.ListN | v == t}"
89:1-89:16::Data.lengthListN_int :: "Data.ListN -> {v : GHC.Types.Int | 0 <= v}"
89:23-89:24::lq_anf$##7205759403792804655 :: "{v : GHC.Prim.Int# | v == 0}"
90:30-90:31::lq_anf$##7205759403792804657 :: "GHC.Types.Int"
90:34-90:51::lq_anf$##7205759403792804658 :: "{v : GHC.Types.Int | v == lengthListN_int t\n                     && 0 <= v}"
90:50-90:51::t :: "{v : Data.ListN | v == t}"
94:1-94:12::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
94:13-94:14::n :: "Data.N"
94:21-94:31::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
94:26-94:27::n :: "{v : Data.N | v == n}"
94:28-94:31::Data.Nil :: "{v : Data.ListN | v == Nil}"
96:6-96:13::lq_anf$##7205759403792804510 :: "{v : GHC.Types.Bool | v == leN n h}"
96:10-96:11::n :: "{v : Data.N | v == n}"
96:12-96:13::h :: "{v : Data.N | v == h}"
97:10-97:27::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
97:15-97:16::n :: "{v : Data.N | v == n}"
97:17-97:27::lq_anf$##7205759403792804513 :: "{v : Data.ListN | v == Cons h t\n                  && lqdc##$select v == h\n                  && lqdc##$select v == t}"
97:23-97:24::h :: "{v : Data.N | v == h}"
97:25-97:26::t :: "{v : Data.ListN | v == t}"
98:10-98:34::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
98:15-98:16::h :: "{v : Data.N | v == h}"
98:17-98:34::lq_anf$##7205759403792804512 :: "{v : Data.ListN | v == insertListN n t}"
98:30-98:31::n :: "{v : Data.N | v == n}"
98:32-98:33::t :: "{v : Data.ListN | v == t}"
102:1-102:10::Data.sortListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == sortListN x1}"
102:17-102:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
103:24-103:51::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
103:36-103:37::h :: "{v : Data.N | v == h}"
103:38-103:51::lq_anf$##7205759403792804515 :: "{v : Data.ListN | v == sortListN t}"
103:49-103:50::t :: "{v : Data.ListN | v == t}"
107:1-107:10::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
107:11-107:12::x :: "Data.N"
107:19-107:24::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
109:6-109:7::x :: "{v : Data.N | v == x}"
109:11-109:12::y :: "{v : Data.N | v == y}"
110:10-110:14::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
111:10-111:24::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
111:20-111:21::x :: "{v : Data.N | v == x}"
111:22-111:24::ys :: "{v : Data.ListN | v == ys}"
115:1-115:10::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
115:17-115:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
116:26-116:29::Data.Nil :: "{v : Data.ListN | v == Nil}"
117:24-117:44::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
117:29-117:30::h :: "{v : Data.N | v == h}"
117:31-117:44::lq_anf$##7205759403792804550 :: "Data.ListN"
117:42-117:43::ds_d2LE :: "Data.ListN"
121:1-121:15::Data.singletonListN :: "x1:Data.N -> {VV : Data.ListN | VV == singletonListN x1\n                                && VV == Cons x1 Nil}"
121:16-121:17::n :: "Data.N"
121:25-121:26::n :: "{v : Data.N | v == n}"
121:27-121:30::Data.Nil :: "{v : Data.ListN | v == Nil}"
125:1-125:10::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
125:11-125:12::x :: "Data.N"
125:19-125:20::x :: "{v : Data.N | v == x}"
126:26-126:39::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
126:36-126:37::h :: "{v : Data.N | v == h}"
126:38-126:39::t :: "{v : Data.ListN | v == t}"
130:1-130:11::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
130:18-130:19::Data.Z :: "{v : Data.N | v == Z}"
131:27-131:28::x :: "{v : Data.N | v == x}"
132:26-132:39::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
132:37-132:39::ds_d2L7 :: "Data.ListN"
137:1-137:10::Data.nullListN :: "x1:Data.ListN -> {VV : GHC.Types.Bool | VV == nullListN x1}"
137:17-137:21::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
138:15-138:20::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
142:1-142:16::Data.initConcatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == initConcatListN x1 x2}"
142:17-142:19::xs :: "Data.ListN"
142:26-142:38::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
142:36-142:38::xs :: "{v : Data.ListN | v == xs}"
143:34-143:63::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
143:46-143:48::xs :: "{v : Data.ListN | v == xs}"
143:49-143:63::lq_anf$##7205759403792804554 :: "{v : Data.ListN | v == initListN ys}"
143:60-143:62::ys :: "{v : Data.ListN | v == ys}"
147:1-147:13::Data.reverseListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == reverseListN x1}"
147:20-147:23::Data.Nil :: "{v : Data.ListN | v == Nil}"
148:27-148:74::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
148:39-148:55::lq_anf$##7205759403792804556 :: "{v : Data.ListN | v == reverseListN t}"
148:53-148:54::t :: "{v : Data.ListN | v == t}"
148:56-148:74::lq_anf$##7205759403792804557 :: "{v : Data.ListN | v == singletonListN h\n                  && v == Cons h Nil}"
148:72-148:73::h :: "{v : Data.N | v == h}"
152:1-152:10::Data.lastOfTwo :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.N | VV == lastOfTwo x1 x2}"
152:11-152:13::xs :: "Data.ListN"
152:20-152:33::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
152:31-152:33::xs :: "{v : Data.ListN | v == xs}"
153:19-153:32::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
153:30-153:32::ds_d2Lc :: "Data.ListN"
157:1-157:12::Data.deleteListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == deleteListN x1 x2}"
157:13-157:14::x :: "Data.N"
157:21-157:24::Data.Nil :: "{v : Data.ListN | v == Nil}"
158:29-158:91::lq_anf$##7205759403792804670 :: "{v : GHC.Types.Bool | (v <=> x == y)\n                      && v == == x y}"
158:32-158:33::x :: "{v : Data.N | v == x}"
158:37-158:38::y :: "{v : Data.N | v == y}"
158:44-158:60::Data.deleteListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == deleteListN x1 x2}"
158:56-158:57::x :: "{v : Data.N | v == x}"
158:58-158:60::ys :: "{v : Data.ListN | v == ys}"
158:66-158:91::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
158:71-158:72::y :: "{v : Data.N | v == y}"
158:73-158:91::lq_anf$##7205759403792804671 :: "{v : Data.ListN | v == deleteListN x ys}"
158:86-158:87::x :: "{v : Data.N | v == x}"
158:88-158:90::ys :: "{v : Data.ListN | v == ys}"
167:1-167:9::Data.zipListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN2 | VV == zipListN x1 x2}"
167:18-167:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
168:18-168:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
169:36-169:62::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
169:42-169:43::x :: "{v : Data.N | v == x}"
169:44-169:45::y :: "{v : Data.N | v == y}"
169:46-169:62::lq_anf$##7205759403792804575 :: "{v : Data.ListN2 | v == zipListN xs ys}"
169:56-169:58::xs :: "{v : Data.ListN | v == xs}"
169:59-169:61::ys :: "{v : Data.ListN | v == ys}"
173:1-173:11::Data.dropListN2 :: "x1:Data.N -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == dropListN2 x1 x2}"
173:18-173:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
174:25-174:29::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
175:37-175:66::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
175:43-175:45::x1 :: "{v : Data.N | v == x1}"
175:46-175:48::x2 :: "Data.N"
175:49-175:66::lq_anf$##7205759403792804582 :: "{v : Data.ListN2 | v == dropListN2 n xs}"
175:61-175:62::n :: "{v : Data.N | v == n}"
175:63-175:65::xs :: "{v : Data.ListN2 | v == xs}"
186:1-186:12::Data.heightTreeN :: "x1:Data.TreeN -> {VV : Data.N | VV == heightTreeN x1}"
186:20-186:21::Data.Z :: "{v : Data.N | v == Z}"
187:28-187:68::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
187:30-187:68::lq_anf$##7205759403792804528 :: "Data.N"
187:36-187:51::lq_anf$##7205759403792804526 :: "{v : Data.N | v == heightTreeN l}"
187:49-187:50::l :: "{v : Data.TreeN | v == l}"
187:52-187:67::lq_anf$##7205759403792804527 :: "{v : Data.N | v == heightTreeN r}"
187:65-187:66::r :: "{v : Data.TreeN | v == r}"
191:1-191:12::Data.mirrorTreeN :: "x1:Data.TreeN -> {VV : Data.TreeN | VV == mirrorTreeN x1}"
191:20-191:24::Data.Leaf :: "{v : Data.TreeN | v == Leaf}"
192:28-192:66::Data.Node :: "x1:Data.N -> x2:Data.TreeN -> x3:Data.TreeN -> {v : Data.TreeN | v == Node x1 x2 x3\n                                                                 && lqdc##$select v == x1\n                                                                 && lqdc##$select v == x2\n                                                                 && lqdc##$select v == x3}"
192:33-192:34::x :: "{v : Data.N | v == x}"
192:35-192:50::lq_anf$##7205759403792804584 :: "{v : Data.TreeN | v == mirrorTreeN r}"
192:48-192:49::r :: "{v : Data.TreeN | v == r}"
192:51-192:66::lq_anf$##7205759403792804585 :: "{v : Data.TreeN | v == mirrorTreeN l}"
192:64-192:65::l :: "{v : Data.TreeN | v == l}"