1:1-1:1::Data.$trModule :: "GHC.Types.Module"
8:1-8:8::Data.implies :: "x1:GHC.Types.Bool -> x2:GHC.Types.Bool -> {VV : GHC.Types.Bool | VV == implies x1 x2\n                                                                 && VV == (if x1 then x2 else true)}"
8:9-8:10::p :: "GHC.Types.Bool"
8:11-8:12::q :: "GHC.Types.Bool"
8:18-8:19::_ :: "{v : GHC.Types.Bool | v == p}"
8:25-8:26::q :: "{v : GHC.Types.Bool | v == q}"
8:32-8:36::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
20:1-20:9::Data.n_to_int :: "Data.N -> {v : GHC.Types.Int | 0 <= v}"
20:14-20:15::lq_anf$##7205759403792804532 :: "{v : GHC.Prim.Int# | v == 0}"
21:18-21:19::lq_anf$##7205759403792804534 :: "GHC.Types.Int"
21:22-21:32::lq_anf$##7205759403792804535 :: "{v : GHC.Types.Int | v == n_to_int n\n                     && 0 <= v}"
21:31-21:32::n :: "{v : Data.N | v == n}"
25:1-25:5::Data.addN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == addN x1 x2}"
25:8-25:9::n :: "Data.N"
25:12-25:13::n :: "{v : Data.N | v == n}"
26:16-26:28::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
26:18-26:28::lq_anf$##7205759403792804369 :: "{v : Data.N | v == addN m n}"
26:24-26:25::m :: "{v : Data.N | v == m}"
26:26-26:27::n :: "{v : Data.N | v == n}"
30:1-30:5::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
30:8-30:9::n :: "Data.N"
30:12-30:13::Data.Z :: "{v : Data.N | v == Z}"
31:12-31:13::ds_d2LQ :: "Data.N"
32:20-32:28::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
32:25-32:26::m :: "{v : Data.N | v == m}"
32:27-32:28::n :: "{v : Data.N | v == n}"
36:1-36:5::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
36:8-36:9::n :: "Data.N"
36:12-36:16::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
37:16-37:21::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
38:20-38:28::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
38:25-38:26::m :: "{v : Data.N | v == m}"
38:27-38:28::n :: "{v : Data.N | v == n}"
42:1-42:4::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
42:7-42:8::n :: "Data.N"
42:11-42:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
43:11-43:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
44:19-44:26::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
44:23-44:24::m :: "{v : Data.N | v == m}"
44:25-44:26::n :: "{v : Data.N | v == n}"
48:1-48:5::Data.maxN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == maxN x1 x2}"
48:8-48:9::n :: "Data.N"
48:12-48:13::n :: "{v : Data.N | v == n}"
49:12-49:13::ds_d2KT :: "Data.N"
50:20-50:32::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
50:22-50:32::lq_anf$##7205759403792804401 :: "{v : Data.N | v == maxN m n}"
50:28-50:29::m :: "{v : Data.N | v == m}"
50:30-50:31::n :: "{v : Data.N | v == n}"
61:1-61:12::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
61:17-61:19::l2 :: "Data.ListN"
61:22-61:24::l2 :: "{v : Data.ListN | v == l2}"
62:30-62:56::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
62:35-62:36::h :: "{v : Data.N | v == h}"
62:37-62:56::lq_anf$##7205759403792804409 :: "{v : Data.ListN | v == concatListN l1 l2}"
62:50-62:52::l1 :: "{v : Data.ListN | v == l1}"
62:53-62:55::l2 :: "{v : Data.ListN | v == l2}"
66:1-66:10::Data.takeListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == takeListN x1 x2}"
66:19-66:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
67:17-67:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
68:30-68:52::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
68:35-68:36::h :: "{v : Data.N | v == h}"
68:37-68:52::lq_anf$##7205759403792804414 :: "{v : Data.ListN | v == takeListN n l}"
68:48-68:49::n :: "{v : Data.N | v == n}"
68:50-68:51::l :: "{v : Data.ListN | v == l}"
72:1-72:10::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
72:19-72:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
73:26-73:34::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
73:31-73:32::h :: "{v : Data.N | v == h}"
73:33-73:34::l :: "{v : Data.ListN | v == l}"
74:30-74:43::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
74:40-74:41::n :: "{v : Data.N | v == n}"
74:42-74:43::l :: "{v : Data.ListN | v == l}"
78:1-78:11::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
78:12-78:13::n :: "Data.N"
78:20-78:21::Data.Z :: "{v : Data.N | v == Z}"
79:27-79:80::lq_anf$##7205759403792804572 :: "{v : GHC.Types.Bool | (v <=> n == h)\n                      && v == == n h}"
79:30-79:31::n :: "{v : Data.N | v == n}"
79:35-79:36::h :: "{v : Data.N | v == h}"
79:42-79:60::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
79:44-79:60::lq_anf$##7205759403792804573 :: "{v : Data.N | v == countListN n l}"
79:56-79:57::n :: "{v : Data.N | v == n}"
79:58-79:59::l :: "{v : Data.ListN | v == l}"
79:66-79:80::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
79:77-79:78::n :: "{v : Data.N | v == n}"
79:79-79:80::l :: "{v : Data.ListN | v == l}"
83:1-83:12::Data.lengthListN :: "x1:Data.ListN -> {VV : Data.N | VV == lengthListN x1}"
83:19-83:20::Data.Z :: "{v : Data.N | v == Z}"
84:26-84:43::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
84:28-84:43::lq_anf$##7205759403792804426 :: "{v : Data.N | v == lengthListN t}"
84:41-84:42::t :: "{v : Data.ListN | v == t}"
89:1-89:16::Data.lengthListN_int :: "Data.ListN -> {v : GHC.Types.Int | 0 <= v}"
89:23-89:24::lq_anf$##7205759403792804527 :: "{v : GHC.Prim.Int# | v == 0}"
90:30-90:31::lq_anf$##7205759403792804529 :: "GHC.Types.Int"
90:34-90:51::lq_anf$##7205759403792804530 :: "{v : GHC.Types.Int | v == lengthListN_int t\n                     && 0 <= v}"
90:50-90:51::t :: "{v : Data.ListN | v == t}"
94:1-94:12::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
94:13-94:14::n :: "Data.N"
94:21-94:31::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
94:26-94:27::n :: "{v : Data.N | v == n}"
94:28-94:31::Data.Nil :: "{v : Data.ListN | v == Nil}"
96:6-96:13::lq_anf$##7205759403792804389 :: "{v : GHC.Types.Bool | v == leN n h}"
96:10-96:11::n :: "{v : Data.N | v == n}"
96:12-96:13::h :: "{v : Data.N | v == h}"
97:10-97:27::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
97:15-97:16::n :: "{v : Data.N | v == n}"
97:17-97:27::lq_anf$##7205759403792804392 :: "{v : Data.ListN | v == Cons h t\n                  && lqdc##$select v == h\n                  && lqdc##$select v == t}"
97:23-97:24::h :: "{v : Data.N | v == h}"
97:25-97:26::t :: "{v : Data.ListN | v == t}"
98:10-98:34::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
98:15-98:16::h :: "{v : Data.N | v == h}"
98:17-98:34::lq_anf$##7205759403792804391 :: "{v : Data.ListN | v == insertListN n t}"
98:30-98:31::n :: "{v : Data.N | v == n}"
98:32-98:33::t :: "{v : Data.ListN | v == t}"
102:1-102:10::Data.sortListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == sortListN x1}"
102:17-102:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
103:24-103:51::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
103:36-103:37::h :: "{v : Data.N | v == h}"
103:38-103:51::lq_anf$##7205759403792804394 :: "{v : Data.ListN | v == sortListN t}"
103:49-103:50::t :: "{v : Data.ListN | v == t}"
107:1-107:10::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
107:11-107:12::x :: "Data.N"
107:19-107:24::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
109:6-109:7::x :: "{v : Data.N | v == x}"
109:11-109:12::y :: "{v : Data.N | v == y}"
110:10-110:14::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
111:10-111:24::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
111:20-111:21::x :: "{v : Data.N | v == x}"
111:22-111:24::ys :: "{v : Data.ListN | v == ys}"
115:1-115:10::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
115:17-115:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
116:26-116:29::Data.Nil :: "{v : Data.ListN | v == Nil}"
117:24-117:44::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
117:29-117:30::h :: "{v : Data.N | v == h}"
117:31-117:44::lq_anf$##7205759403792804429 :: "Data.ListN"
117:42-117:43::ds_d2JH :: "Data.ListN"
121:1-121:15::Data.singletonListN :: "x1:Data.N -> {VV : Data.ListN | VV == singletonListN x1\n                                && VV == Cons x1 Nil}"
121:16-121:17::n :: "Data.N"
121:25-121:26::n :: "{v : Data.N | v == n}"
121:27-121:30::Data.Nil :: "{v : Data.ListN | v == Nil}"
125:1-125:10::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
125:11-125:12::x :: "Data.N"
125:19-125:20::x :: "{v : Data.N | v == x}"
126:26-126:39::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
126:36-126:37::h :: "{v : Data.N | v == h}"
126:38-126:39::t :: "{v : Data.ListN | v == t}"
130:1-130:10::Data.nullListN :: "x1:Data.ListN -> {VV : GHC.Types.Bool | VV == nullListN x1}"
130:17-130:21::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
131:15-131:20::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
135:1-135:16::Data.initConcatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == initConcatListN x1 x2}"
135:17-135:19::xs :: "Data.ListN"
135:26-135:38::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
135:36-135:38::xs :: "{v : Data.ListN | v == xs}"
136:34-136:63::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
136:46-136:48::xs :: "{v : Data.ListN | v == xs}"
136:49-136:63::lq_anf$##7205759403792804433 :: "{v : Data.ListN | v == initListN ys}"
136:60-136:62::ys :: "{v : Data.ListN | v == ys}"
140:1-140:13::Data.reverseListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == reverseListN x1}"
140:20-140:23::Data.Nil :: "{v : Data.ListN | v == Nil}"
141:27-141:74::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
141:39-141:55::lq_anf$##7205759403792804435 :: "{v : Data.ListN | v == reverseListN t}"
141:53-141:54::t :: "{v : Data.ListN | v == t}"
141:56-141:74::lq_anf$##7205759403792804436 :: "{v : Data.ListN | v == singletonListN h\n                  && v == Cons h Nil}"
141:72-141:73::h :: "{v : Data.N | v == h}"
150:1-150:9::Data.zipListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN2 | VV == zipListN x1 x2}"
150:18-150:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
151:18-151:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
152:36-152:62::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
152:42-152:43::x :: "{v : Data.N | v == x}"
152:44-152:45::y :: "{v : Data.N | v == y}"
152:46-152:62::lq_anf$##7205759403792804447 :: "{v : Data.ListN2 | v == zipListN xs ys}"
152:56-152:58::xs :: "{v : Data.ListN | v == xs}"
152:59-152:61::ys :: "{v : Data.ListN | v == ys}"
156:1-156:11::Data.dropListN2 :: "x1:Data.N -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == dropListN2 x1 x2}"
156:18-156:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
157:25-157:29::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
158:37-158:66::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
158:43-158:45::x1 :: "{v : Data.N | v == x1}"
158:46-158:48::x2 :: "Data.N"
158:49-158:66::lq_anf$##7205759403792804454 :: "{v : Data.ListN2 | v == dropListN2 n xs}"
158:61-158:62::n :: "{v : Data.N | v == n}"
158:63-158:65::xs :: "{v : Data.ListN2 | v == xs}"
169:1-169:12::Data.heightTreeN :: "x1:Data.TreeN -> {VV : Data.N | VV == heightTreeN x1}"
169:20-169:21::Data.Z :: "{v : Data.N | v == Z}"
170:28-170:68::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
170:30-170:68::lq_anf$##7205759403792804407 :: "Data.N"
170:36-170:51::lq_anf$##7205759403792804405 :: "{v : Data.N | v == heightTreeN l}"
170:49-170:50::l :: "{v : Data.TreeN | v == l}"
170:52-170:67::lq_anf$##7205759403792804406 :: "{v : Data.N | v == heightTreeN r}"
170:65-170:66::r :: "{v : Data.TreeN | v == r}"
174:1-174:12::Data.mirrorTreeN :: "x1:Data.TreeN -> {VV : Data.TreeN | VV == mirrorTreeN x1}"
174:20-174:24::Data.Leaf :: "{v : Data.TreeN | v == Leaf}"
175:28-175:66::Data.Node :: "x1:Data.N -> x2:Data.TreeN -> x3:Data.TreeN -> {v : Data.TreeN | v == Node x1 x2 x3\n                                                                 && lqdc##$select v == x1\n                                                                 && lqdc##$select v == x2\n                                                                 && lqdc##$select v == x3}"
175:33-175:34::x :: "{v : Data.N | v == x}"
175:35-175:50::lq_anf$##7205759403792804456 :: "{v : Data.TreeN | v == mirrorTreeN r}"
175:48-175:49::r :: "{v : Data.TreeN | v == r}"
175:51-175:66::lq_anf$##7205759403792804457 :: "{v : Data.TreeN | v == mirrorTreeN l}"
175:64-175:65::l :: "{v : Data.TreeN | v == l}"