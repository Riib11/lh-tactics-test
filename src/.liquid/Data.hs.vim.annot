1:1-1:1::Data.$trModule :: "GHC.Types.Module"
10:1-10:8::Data.implies :: "x1:GHC.Types.Bool -> x2:GHC.Types.Bool -> {VV : GHC.Types.Bool | VV == implies x1 x2\n                                                                 && VV == (if x1 then x2 else true)}"
10:9-10:10::p :: "GHC.Types.Bool"
10:11-10:12::q :: "GHC.Types.Bool"
10:18-10:19::_ :: "{v : GHC.Types.Bool | v == p}"
10:25-10:26::q :: "{v : GHC.Types.Bool | v == q}"
10:32-10:36::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
16:1-16:11::Data.assumption :: "x1:GHC.Types.Bool -> {VV : () | x1}"
16:12-16:13::b :: "GHC.Types.Bool"
22:1-22:9::Data.constant :: "forall a b .\nx1:a -> x2:b -> {VV : a | VV == x1\n                          && VV == constant x1 x2}"
22:10-22:11::a :: "a"
34:1-34:9::Data.n_to_int :: "Data.N -> {v : GHC.Types.Int | 0 <= v}"
34:14-34:15::lq_anf$##7205759403792805242 :: "{v : GHC.Prim.Int# | v == 0}"
35:18-35:19::lq_anf$##7205759403792805244 :: "GHC.Types.Int"
35:22-35:32::lq_anf$##7205759403792805245 :: "{v : GHC.Types.Int | v == n_to_int n\n                     && 0 <= v}"
35:31-35:32::n :: "{v : Data.N | v == n}"
39:1-39:5::Data.addN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == addN x1 x2}"
39:8-39:9::n :: "Data.N"
39:12-39:13::n :: "{v : Data.N | v == n}"
40:16-40:28::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
40:18-40:28::lq_anf$##7205759403792805011 :: "{v : Data.N | v == addN m n}"
40:24-40:25::m :: "{v : Data.N | v == m}"
40:26-40:27::n :: "{v : Data.N | v == n}"
44:1-44:5::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
44:8-44:9::n :: "Data.N"
44:12-44:13::Data.Z :: "{v : Data.N | v == Z}"
45:12-45:13::ds_d2WH :: "Data.N"
46:20-46:28::Data.subN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == subN x1 x2}"
46:25-46:26::m :: "{v : Data.N | v == m}"
46:27-46:28::n :: "{v : Data.N | v == n}"
50:1-50:5::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
50:8-50:9::n :: "Data.N"
50:12-50:16::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
51:16-51:21::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
52:20-52:28::Data.leqN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leqN x1 x2}"
52:25-52:26::m :: "{v : Data.N | v == m}"
52:27-52:28::n :: "{v : Data.N | v == n}"
56:1-56:4::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
56:11-56:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
57:15-57:19::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
58:11-58:16::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
59:19-59:26::Data.leN :: "x1:Data.N -> x2:Data.N -> {VV : GHC.Types.Bool | VV == leN x1 x2}"
59:23-59:24::m :: "{v : Data.N | v == m}"
59:25-59:26::n :: "{v : Data.N | v == n}"
63:1-63:5::Data.maxN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == maxN x1 x2}"
63:8-63:9::n :: "Data.N"
63:12-63:13::n :: "{v : Data.N | v == n}"
64:12-64:13::ds_d2Vu :: "Data.N"
65:20-65:32::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
65:22-65:32::lq_anf$##7205759403792805048 :: "{v : Data.N | v == maxN m n}"
65:28-65:29::m :: "{v : Data.N | v == m}"
65:30-65:31::n :: "{v : Data.N | v == n}"
69:1-69:5::Data.minN :: "x1:Data.N -> x2:Data.N -> {VV : Data.N | VV == minN x1 x2}"
69:8-69:9::n :: "Data.N"
69:12-69:13::Data.Z :: "{v : Data.N | v == Z}"
70:12-70:13::Data.Z :: "{v : Data.N | v == Z}"
71:20-71:32::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
71:22-71:32::lq_anf$##7205759403792805061 :: "{v : Data.N | v == minN m n}"
71:28-71:29::m :: "{v : Data.N | v == m}"
71:30-71:31::n :: "{v : Data.N | v == n}"
82:1-82:12::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
82:17-82:19::l2 :: "Data.ListN"
82:22-82:24::l2 :: "{v : Data.ListN | v == l2}"
83:30-83:56::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
83:35-83:36::h :: "{v : Data.N | v == h}"
83:37-83:56::lq_anf$##7205759403792805065 :: "{v : Data.ListN | v == concatListN l1 l2}"
83:50-83:52::l1 :: "{v : Data.ListN | v == l1}"
83:53-83:55::l2 :: "{v : Data.ListN | v == l2}"
87:1-87:10::Data.takeListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == takeListN x1 x2}"
87:19-87:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
88:17-88:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
89:30-89:52::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
89:35-89:36::h :: "{v : Data.N | v == h}"
89:37-89:52::lq_anf$##7205759403792805070 :: "{v : Data.ListN | v == takeListN n l}"
89:48-89:49::n :: "{v : Data.N | v == n}"
89:50-89:51::l :: "{v : Data.ListN | v == l}"
93:1-93:10::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
93:19-93:22::Data.Nil :: "{v : Data.ListN | v == Nil}"
94:17-94:18::ds_d2Uy :: "Data.ListN"
95:30-95:43::Data.dropListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == dropListN x1 x2}"
95:40-95:41::n :: "{v : Data.N | v == n}"
95:42-95:43::l :: "{v : Data.ListN | v == l}"
99:1-99:15::Data.dropWhileListN :: "x1:(Data.N -> GHC.Types.Bool) -> x3:Data.ListN -> {VV : Data.ListN | VV == dropWhileListN x1 x3}"
99:16-99:17::f :: "Data.N -> GHC.Types.Bool"
99:24-99:27::Data.Nil :: "{v : Data.ListN | v == Nil}"
101:3-101:49::lq_anf$##7205759403792805081 :: "{v : GHC.Types.Bool | v == f x}"
101:6-101:9::lq_anf$##7205759403792805080 :: "{v : GHC.Types.Bool | v == f x}"
101:8-101:9::x :: "{v : Data.N | v == x}"
101:15-101:34::Data.dropWhileListN :: "x1:(Data.N -> GHC.Types.Bool) -> x3:Data.ListN -> {VV : Data.ListN | VV == dropWhileListN x1 x3}"
101:30-101:31::f :: "Data.N -> GHC.Types.Bool"
101:32-101:34::xs :: "{v : Data.ListN | v == xs}"
101:40-101:49::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
101:45-101:46::x :: "{v : Data.N | v == x}"
101:47-101:49::xs :: "{v : Data.ListN | v == xs}"
105:1-105:15::Data.takeWhileListN :: "x1:(Data.N -> GHC.Types.Bool) -> x3:Data.ListN -> {VV : Data.ListN | VV == takeWhileListN x1 x3}"
105:16-105:17::f :: "Data.N -> GHC.Types.Bool"
105:24-105:27::Data.Nil :: "{v : Data.ListN | v == Nil}"
107:3-107:52::lq_anf$##7205759403792805084 :: "{v : GHC.Types.Bool | v == f x}"
107:6-107:9::lq_anf$##7205759403792805083 :: "{v : GHC.Types.Bool | v == f x}"
107:8-107:9::x :: "{v : Data.N | v == x}"
107:15-107:43::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
107:20-107:21::x :: "{v : Data.N | v == x}"
107:22-107:43::lq_anf$##7205759403792805085 :: "{v : Data.ListN | v == takeWhileListN f xs}"
107:38-107:39::f :: "Data.N -> GHC.Types.Bool"
107:40-107:42::xs :: "{v : Data.ListN | v == xs}"
107:49-107:52::Data.Nil :: "{v : Data.ListN | v == Nil}"
111:1-111:11::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
111:12-111:13::n :: "Data.N"
111:20-111:21::Data.Z :: "{v : Data.N | v == Z}"
113:3-113:56::lq_anf$##7205759403792805290 :: "{v : GHC.Types.Bool | (v <=> n == h)\n                      && v == == n h}"
113:6-113:7::n :: "{v : Data.N | v == n}"
113:11-113:12::h :: "{v : Data.N | v == h}"
113:18-113:36::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
113:20-113:36::lq_anf$##7205759403792805291 :: "{v : Data.N | v == countListN n l}"
113:32-113:33::n :: "{v : Data.N | v == n}"
113:34-113:35::l :: "{v : Data.ListN | v == l}"
113:42-113:56::Data.countListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == countListN x1 x2}"
113:53-113:54::n :: "{v : Data.N | v == n}"
113:55-113:56::l :: "{v : Data.ListN | v == l}"
117:1-117:12::Data.lengthListN :: "x1:Data.ListN -> {VV : Data.N | VV == lengthListN x1}"
117:19-117:20::Data.Z :: "{v : Data.N | v == Z}"
118:26-118:43::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
118:28-118:43::lq_anf$##7205759403792805087 :: "{v : Data.N | v == lengthListN t}"
118:41-118:42::t :: "{v : Data.ListN | v == t}"
123:1-123:16::Data.lengthListN_int :: "Data.ListN -> {v : GHC.Types.Int | 0 <= v}"
123:23-123:24::lq_anf$##7205759403792805237 :: "{v : GHC.Prim.Int# | v == 0}"
124:30-124:31::lq_anf$##7205759403792805239 :: "GHC.Types.Int"
124:34-124:51::lq_anf$##7205759403792805240 :: "{v : GHC.Types.Int | v == lengthListN_int t\n                     && 0 <= v}"
124:50-124:51::t :: "{v : Data.ListN | v == t}"
128:1-128:12::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
128:13-128:14::n :: "Data.N"
128:21-128:31::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
128:26-128:27::n :: "{v : Data.N | v == n}"
128:28-128:31::Data.Nil :: "{v : Data.ListN | v == Nil}"
130:6-130:13::lq_anf$##7205759403792805036 :: "{v : GHC.Types.Bool | v == leN n h}"
130:10-130:11::n :: "{v : Data.N | v == n}"
130:12-130:13::h :: "{v : Data.N | v == h}"
131:10-131:27::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
131:15-131:16::n :: "{v : Data.N | v == n}"
131:17-131:27::lq_anf$##7205759403792805039 :: "{v : Data.ListN | v == Cons h t\n                  && lqdc##$select v == h\n                  && lqdc##$select v == t}"
131:23-131:24::h :: "{v : Data.N | v == h}"
131:25-131:26::t :: "{v : Data.ListN | v == t}"
132:10-132:34::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
132:15-132:16::h :: "{v : Data.N | v == h}"
132:17-132:34::lq_anf$##7205759403792805038 :: "{v : Data.ListN | v == insertListN n t}"
132:30-132:31::n :: "{v : Data.N | v == n}"
132:32-132:33::t :: "{v : Data.ListN | v == t}"
136:1-136:10::Data.sortListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == sortListN x1}"
136:17-136:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
137:24-137:51::Data.insertListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == insertListN x1 x2}"
137:36-137:37::h :: "{v : Data.N | v == h}"
137:38-137:51::lq_anf$##7205759403792805041 :: "{v : Data.ListN | v == sortListN t}"
137:49-137:50::t :: "{v : Data.ListN | v == t}"
141:1-141:12::Data.sortedListN :: "x1:Data.ListN -> {VV : GHC.Types.Bool | VV == sortedListN x1}"
141:19-141:23::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
142:28-142:32::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
143:44-143:54::lq_anf$##7205759403792805024 :: "{v : GHC.Types.Bool | v == leqN x v}"
143:49-143:51::x :: "{v : Data.N | v == x}"
143:52-143:54::x2 :: "Data.N"
143:58-143:73::lq_anf$##7205759403792805025 :: "GHC.Types.Bool"
143:70-143:73::ds_d2WG :: "Data.ListN"
147:1-147:10::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
147:11-147:12::x :: "Data.N"
147:19-147:24::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
149:6-149:7::x :: "{v : Data.N | v == x}"
149:11-149:12::y :: "{v : Data.N | v == y}"
150:10-150:14::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
151:10-151:24::Data.elemListN :: "x1:Data.N -> x2:Data.ListN -> {VV : GHC.Types.Bool | VV == elemListN x1 x2}"
151:20-151:21::x :: "{v : Data.N | v == x}"
151:22-151:24::ys :: "{v : Data.ListN | v == ys}"
155:1-155:10::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
155:17-155:20::Data.Nil :: "{v : Data.ListN | v == Nil}"
156:26-156:29::Data.Nil :: "{v : Data.ListN | v == Nil}"
157:24-157:44::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
157:29-157:30::h :: "{v : Data.N | v == h}"
157:31-157:44::lq_anf$##7205759403792805090 :: "Data.ListN"
157:42-157:43::ds_d2TS :: "Data.ListN"
161:1-161:15::Data.singletonListN :: "x1:Data.N -> {VV : Data.ListN | VV == singletonListN x1\n                                && VV == Cons x1 Nil}"
161:16-161:17::n :: "Data.N"
161:25-161:26::n :: "{v : Data.N | v == n}"
161:27-161:30::Data.Nil :: "{v : Data.ListN | v == Nil}"
165:1-165:5::Data.ins1 :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == ins1 x1 x2}"
165:6-165:7::n :: "Data.N"
165:14-165:30::Data.singletonListN :: "x1:Data.N -> {v : Data.ListN | v == singletonListN x1\n                               && v == Cons x1 Nil}"
165:29-165:30::n :: "{v : Data.N | v == n}"
167:6-167:7::n :: "{v : Data.N | v == n}"
167:11-167:12::x :: "{v : Data.N | v == x}"
168:10-168:19::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
168:15-168:16::x :: "{v : Data.N | v == x}"
168:17-168:19::xs :: "{v : Data.ListN | v == xs}"
169:10-169:28::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
169:15-169:16::x :: "{v : Data.N | v == x}"
169:17-169:28::lq_anf$##7205759403792805284 :: "{v : Data.ListN | v == ins1 n xs}"
169:23-169:24::n :: "{v : Data.N | v == n}"
169:25-169:27::xs :: "{v : Data.ListN | v == xs}"
173:1-173:10::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
173:11-173:12::x :: "Data.N"
173:19-173:20::x :: "{v : Data.N | v == x}"
174:26-174:39::Data.lastListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.N | VV == lastListN x1 x2}"
174:36-174:37::h :: "{v : Data.N | v == h}"
174:38-174:39::t :: "{v : Data.ListN | v == t}"
178:1-178:11::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
178:18-178:19::Data.Z :: "{v : Data.N | v == Z}"
179:27-179:28::x :: "{v : Data.N | v == x}"
180:26-180:39::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
180:37-180:39::ds_d2Tc :: "Data.ListN"
185:1-185:10::Data.nullListN :: "x1:Data.ListN -> {VV : GHC.Types.Bool | VV == nullListN x1}"
185:17-185:21::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
186:15-186:20::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
190:1-190:16::Data.initConcatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == initConcatListN x1 x2}"
190:17-190:19::xs :: "Data.ListN"
190:26-190:38::Data.initListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == initListN x1}"
190:36-190:38::xs :: "{v : Data.ListN | v == xs}"
191:34-191:63::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
191:46-191:48::xs :: "{v : Data.ListN | v == xs}"
191:49-191:63::lq_anf$##7205759403792805094 :: "{v : Data.ListN | v == initListN ys}"
191:60-191:62::ys :: "{v : Data.ListN | v == ys}"
195:1-195:13::Data.reverseListN :: "x1:Data.ListN -> {VV : Data.ListN | VV == reverseListN x1}"
195:20-195:23::Data.Nil :: "{v : Data.ListN | v == Nil}"
196:27-196:74::Data.concatListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN | VV == concatListN x1 x2}"
196:39-196:55::lq_anf$##7205759403792805096 :: "{v : Data.ListN | v == reverseListN t}"
196:53-196:54::t :: "{v : Data.ListN | v == t}"
196:56-196:74::lq_anf$##7205759403792805097 :: "{v : Data.ListN | v == singletonListN h\n                  && v == Cons h Nil}"
196:72-196:73::h :: "{v : Data.N | v == h}"
200:1-200:10::Data.lastOfTwo :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.N | VV == lastOfTwo x1 x2}"
200:11-200:13::xs :: "Data.ListN"
200:20-200:33::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
200:31-200:33::xs :: "{v : Data.ListN | v == xs}"
201:19-201:32::Data.lastListN' :: "x1:Data.ListN -> {VV : Data.N | VV == lastListN' x1}"
201:30-201:32::ds_d2Th :: "Data.ListN"
205:1-205:12::Data.deleteListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == deleteListN x1 x2}"
205:13-205:14::x :: "Data.N"
205:21-205:24::Data.Nil :: "{v : Data.ListN | v == Nil}"
206:29-206:91::lq_anf$##7205759403792805252 :: "{v : GHC.Types.Bool | (v <=> x == y)\n                      && v == == x y}"
206:32-206:33::x :: "{v : Data.N | v == x}"
206:37-206:38::y :: "{v : Data.N | v == y}"
206:44-206:60::Data.deleteListN :: "x1:Data.N -> x2:Data.ListN -> {VV : Data.ListN | VV == deleteListN x1 x2}"
206:56-206:57::x :: "{v : Data.N | v == x}"
206:58-206:60::ys :: "{v : Data.ListN | v == ys}"
206:66-206:91::Data.Cons :: "x1:Data.N -> x2:Data.ListN -> {v : Data.ListN | v == Cons x1 x2\n                                                && lqdc##$select v == x1\n                                                && lqdc##$select v == x2}"
206:71-206:72::y :: "{v : Data.N | v == y}"
206:73-206:91::lq_anf$##7205759403792805253 :: "{v : Data.ListN | v == deleteListN x ys}"
206:86-206:87::x :: "{v : Data.N | v == x}"
206:88-206:90::ys :: "{v : Data.ListN | v == ys}"
215:1-215:9::Data.zipListN :: "x1:Data.ListN -> x2:Data.ListN -> {VV : Data.ListN2 | VV == zipListN x1 x2}"
215:18-215:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
216:18-216:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
217:36-217:62::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
217:42-217:43::x :: "{v : Data.N | v == x}"
217:44-217:45::y :: "{v : Data.N | v == y}"
217:46-217:62::lq_anf$##7205759403792805115 :: "{v : Data.ListN2 | v == zipListN xs ys}"
217:56-217:58::xs :: "{v : Data.ListN | v == xs}"
217:59-217:61::ys :: "{v : Data.ListN | v == ys}"
221:1-221:11::Data.dropListN2 :: "x1:Data.N -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == dropListN2 x1 x2}"
221:14-221:16::xs :: "Data.ListN2"
221:19-221:21::xs :: "{v : Data.ListN2 | v == xs}"
222:21-222:25::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
223:37-223:52::Data.dropListN2 :: "x1:Data.N -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == dropListN2 x1 x2}"
223:48-223:49::n :: "{v : Data.N | v == n}"
223:50-223:52::xs :: "{v : Data.ListN2 | v == xs}"
227:1-227:11::Data.takeListN2 :: "x1:Data.N -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == takeListN2 x1 x2}"
227:18-227:22::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
228:21-228:25::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
229:37-229:66::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
229:43-229:45::x1 :: "{v : Data.N | v == x1}"
229:46-229:48::x2 :: "Data.N"
229:49-229:66::lq_anf$##7205759403792805136 :: "{v : Data.ListN2 | v == takeListN2 n xs}"
229:61-229:62::n :: "{v : Data.N | v == n}"
229:63-229:65::xs :: "{v : Data.ListN2 | v == xs}"
233:1-233:13::Data.concatListN2 :: "x1:Data.ListN2 -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == concatListN2 x1 x2}"
233:19-233:21::ys :: "Data.ListN2"
233:24-233:26::ys :: "{v : Data.ListN2 | v == ys}"
234:36-234:68::Data.Cons2 :: "x1:Data.N -> x2:Data.N -> x3:Data.ListN2 -> {v : Data.ListN2 | v == Cons2 x1 x2 x3\n                                                               && lqdc##$select v == x1\n                                                               && lqdc##$select v == x2\n                                                               && lqdc##$select v == x3}"
234:42-234:44::x1 :: "{v : Data.N | v == x1}"
234:45-234:47::x2 :: "Data.N"
234:48-234:68::lq_anf$##7205759403792805142 :: "{v : Data.ListN2 | v == concatListN2 xs ys}"
234:62-234:64::xs :: "{v : Data.ListN2 | v == xs}"
234:65-234:67::ys :: "{v : Data.ListN2 | v == ys}"
238:1-238:16::Data.singletonListN2 :: "x1:Data.N -> x2:Data.N -> {VV : Data.ListN2 | VV == singletonListN2 x1 x2\n                                              && VV == Cons2 x1 x2 Nil2}"
238:17-238:19::x1 :: "Data.N"
238:20-238:22::x2 :: "Data.N"
238:31-238:33::x1 :: "{v : Data.N | v == x1}"
238:34-238:36::x2 :: "Data.N"
238:37-238:41::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
242:1-242:14::Data.reverseListN2 :: "x1:Data.ListN2 -> {VV : Data.ListN2 | VV == reverseListN2 x1}"
242:22-242:26::Data.Nil2 :: "{v : Data.ListN2 | v == Nil2}"
243:34-243:89::Data.concatListN2 :: "x1:Data.ListN2 -> x2:Data.ListN2 -> {VV : Data.ListN2 | VV == concatListN2 x1 x2}"
243:47-243:65::lq_anf$##7205759403792805144 :: "{v : Data.ListN2 | v == reverseListN2 xs}"
243:62-243:64::xs :: "{v : Data.ListN2 | v == xs}"
243:66-243:89::lq_anf$##7205759403792805145 :: "{v : Data.ListN2 | v == singletonListN2 x1 v\n                   && v == Cons2 x1 v Nil2}"
243:83-243:85::x1 :: "{v : Data.N | v == x1}"
243:86-243:88::x2 :: "Data.N"
254:1-254:12::Data.heightTreeN :: "x1:Data.TreeN -> {VV : Data.N | VV == heightTreeN x1}"
254:20-254:21::Data.Z :: "{v : Data.N | v == Z}"
255:28-255:68::Data.S :: "x1:Data.N -> {v : Data.N | v == S x1\n                           && lqdc##$select v == x1}"
255:30-255:68::lq_anf$##7205759403792805054 :: "Data.N"
255:36-255:51::lq_anf$##7205759403792805052 :: "{v : Data.N | v == heightTreeN l}"
255:49-255:50::l :: "{v : Data.TreeN | v == l}"
255:52-255:67::lq_anf$##7205759403792805053 :: "{v : Data.N | v == heightTreeN r}"
255:65-255:66::r :: "{v : Data.TreeN | v == r}"
259:1-259:12::Data.mirrorTreeN :: "x1:Data.TreeN -> {VV : Data.TreeN | VV == mirrorTreeN x1}"
259:20-259:24::Data.Leaf :: "{v : Data.TreeN | v == Leaf}"
260:28-260:66::Data.Node :: "x1:Data.N -> x2:Data.TreeN -> x3:Data.TreeN -> {v : Data.TreeN | v == Node x1 x2 x3\n                                                                 && lqdc##$select v == x1\n                                                                 && lqdc##$select v == x2\n                                                                 && lqdc##$select v == x3}"
260:33-260:34::x :: "{v : Data.N | v == x}"
260:35-260:50::lq_anf$##7205759403792805147 :: "{v : Data.TreeN | v == mirrorTreeN r}"
260:48-260:49::r :: "{v : Data.TreeN | v == r}"
260:51-260:66::lq_anf$##7205759403792805148 :: "{v : Data.TreeN | v == mirrorTreeN l}"
260:64-260:65::l :: "{v : Data.TreeN | v == l}"