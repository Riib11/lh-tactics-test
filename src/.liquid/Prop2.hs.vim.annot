1:1-1:1::Prop2.$trModule :: "GHC.Types.Module"
17:1-17:6::Prop2.prop2 :: "x1:Data.N -> x2:Data.NL -> x3:Data.NL -> {VV : GHC.Types.Bool | VV == prop2 x1 x2 x3\n                                                                && VV == (addN (countNL x1 x2) (countNL x1 x3) == countNL x1 (concatNL x2 x3))}"
17:7-17:8::n :: "Data.N"
17:9-17:11::xs :: "Data.NL"
17:12-17:14::ys :: "Data.NL"
17:17-17:51::lq_anf$##7205759403792811233 :: "Data.N"
17:22-17:36::lq_anf$##7205759403792811231 :: "{v : Data.N | v == countNL n xs}"
17:31-17:32::n :: "{v : Data.N | v == n}"
17:33-17:35::xs :: "{v : Data.NL | v == xs}"
17:37-17:51::lq_anf$##7205759403792811232 :: "{v : Data.N | v == countNL n ys}"
17:46-17:47::n :: "{v : Data.N | v == n}"
17:48-17:50::ys :: "{v : Data.NL | v == ys}"
17:55-17:81::lq_anf$##7205759403792811235 :: "Data.N"
17:63-17:64::n :: "{v : Data.N | v == n}"
17:65-17:81::lq_anf$##7205759403792811234 :: "{v : Data.NL | v == concatNL xs ys}"
17:75-17:77::xs :: "{v : Data.NL | v == xs}"
17:78-17:80::ys :: "{v : Data.NL | v == ys}"
27:1-27:12::Prop2.prop2_check :: "x1:Data.N -> x2:Data.NL -> x3:Data.NL -> {VV : () | prop2 x1 x2 x3}"
27:16-27:17::n :: "Data.N"
27:22-27:24::xs :: "Data.NL"
27:29-27:31::ys :: "Data.NL"
27:40-27:42::_ :: "{v : Data.NL | v == xs}"
28:51-28:58::Proof.trivial :: "{v : () | v == ()\n          && v == trivial}"
29:61-29:82::lq_anf$##7205759403792811226 :: "{v : () | prop2 n nL_1 ys\n          && v == prop2_check n nL_1 ys}"
29:73-29:74::n :: "{v : Data.N | v == n}"
29:75-29:79::nL_1 :: "{v : Data.NL | v == nL_1}"
29:80-29:82::ys :: "{v : Data.NL | v == ys}"
29:87-29:94::Proof.trivial :: "{v : () | v == ()\n          && v == trivial}"