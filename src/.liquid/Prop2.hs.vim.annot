1:1-1:1::Prop2.$trModule :: "GHC.Types.Module"
16:1-16:6::Prop2.prop2 :: "x1:Data.N -> x2:Data.NL -> x3:Data.NL -> {VV : GHC.Types.Bool | VV == prop2 x1 x2 x3\n                                                                && VV == (addN (countNL x1 x2) (countNL x1 x3) == countNL x1 (concatNL x2 x3))}"
16:7-16:8::n :: "Data.N"
16:9-16:11::xs :: "Data.NL"
16:12-16:14::ys :: "Data.NL"
16:17-16:51::lq_anf$##7205759403792810635 :: "Data.N"
16:22-16:36::lq_anf$##7205759403792810633 :: "{v : Data.N | v == countNL n xs}"
16:31-16:32::n :: "{v : Data.N | v == n}"
16:33-16:35::xs :: "{v : Data.NL | v == xs}"
16:37-16:51::lq_anf$##7205759403792810634 :: "{v : Data.N | v == countNL n ys}"
16:46-16:47::n :: "{v : Data.N | v == n}"
16:48-16:50::ys :: "{v : Data.NL | v == ys}"
16:55-16:81::lq_anf$##7205759403792810637 :: "Data.N"
16:63-16:64::n :: "{v : Data.N | v == n}"
16:65-16:81::lq_anf$##7205759403792810636 :: "{v : Data.NL | v == concatNL xs ys}"
16:75-16:77::xs :: "{v : Data.NL | v == xs}"
16:78-16:80::ys :: "{v : Data.NL | v == ys}"
26:1-26:12::Prop2.prop2_proof :: "x1:Data.N -> x2:Data.NL -> x3:Data.NL -> {VV : () | prop2 x1 x2 x3}"
26:16-26:17::n :: "Data.N"
26:22-26:24::xs :: "Data.NL"
26:29-26:31::ys :: "Data.NL"
26:40-26:42::_ :: "{v : Data.NL | v == xs}"
27:51-27:58::Proof.trivial :: "{v : () | v == trivial}"
28:61-28:82::Prop2.prop2_proof :: "x1:Data.N -> x2:Data.NL -> x3:Data.NL -> {VV : () | prop2 x1 x2 x3}"
28:73-28:74::n :: "{v : Data.N | v == n}"
28:75-28:79::nL_1 :: "{v : Data.NL | v == nL_1}"
28:80-28:82::ys :: "{v : Data.NL | v == ys}"